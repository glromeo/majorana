{"version":3,"sources":["../../src/main/interpreter.js"],"names":["valueOf","String","eval","Number","Interpreter","constructor","parser","parse","expression","ast","context","self","Promise","resolve","type","Expression","callback","AssignmentExpression","left","right","Identifier","name","object","member","computed","CommaExpression","list","pending","length","p","next","value","TernaryExpression","test","consequent","alternate","then","text","CallExpression","callee","parameters","args","Array","parameter","result","call","SelfExpression","ignored","MemberExpression","ArrayExpression","elements","array","element","Property","key","ObjectExpression","properties","property","BinaryExpression","operators","operator","UnaryExpression","prefix","argument","prototype","LogicalExpression","Logical","EqualityExpression","Equality","RelationalExpression","Relational","AdditiveExpression","Additive","MultiplicativeExpression","Multiplicative","Unary","Literal"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA,MAAMA,UAAU;AACZ,KAAC,SAAIC,MAAL,GAAcC,IADF;AAEZ,KAAC,SAAIC,MAAL,GAAcA;AAFF,CAAhB;;IAKaC,W,WAAAA,W,GAAN,MAAMA,WAAN,CAAkB;;AAErBC,gBAAYC,SAAS,oBAArB,EAAmC;AAC/B,aAAKA,MAAL,GAAcA,MAAd;AACH;;AAEDC,UAAMC,UAAN,EAAkB;AACd,aAAKC,GAAL,GAAW,KAAKH,MAAL,CAAYC,KAAZ,CAAkBC,UAAlB,CAAX;AACH;;AAEDN,SAAKQ,OAAL,EAAcC,IAAd,EAAoB;AAChB,aAAKD,OAAL,GAAeA,OAAf;AACA,aAAKC,IAAL,GAAYA,IAAZ;AACA,eAAO,IAAIC,OAAJ,CAAYC,WAAW,KAAK,KAAKJ,GAAL,CAASK,IAAd,EAAoB,KAAKL,GAAzB,EAA8BI,OAA9B,CAAvB,CAAP;AACH;;AAED,KAAC,SAAIE,UAAL,EAAiB,EAACP,UAAD,EAAjB,EAA+BQ,QAA/B,EAAyC;AACrC,aAAKR,WAAWM,IAAhB,EAAsBN,UAAtB,EAAkCQ,QAAlC;AACH;;AAED,KAAC,SAAIC,oBAAL,EAA2B,EAACC,IAAD,EAAOC,KAAP,EAA3B,EAA0CH,QAA1C,EAAoD;AAChD,aAAKG,MAAML,IAAX,EAAiBK,KAAjB,EAAwBA,SAAS;AAC7B,gBAAID,KAAKJ,IAAL,KAAc,SAAIM,UAAtB,EAAkC;AAC9BJ,yBAAS,KAAKN,OAAL,CAAaQ,KAAKG,IAAlB,IAA0BF,KAAnC;AACH,aAFD,MAEO;AACH,qBAAKD,KAAKI,MAAL,CAAYR,IAAjB,EAAuBI,KAAKI,MAA5B,EAAoCA,UAAU;AAC1C,0BAAMC,SAASL,KAAKK,MAApB;AACA,wBAAIL,KAAKM,QAAT,EAAmB;AACf,6BAAKD,OAAOT,IAAZ,EAAkBS,MAAlB,EAA0BA,UAAUP,SAASM,OAAOC,MAAP,IAAiBJ,KAA1B,CAApC;AACH,qBAFD,MAEO;AACHH,iCAASM,OAAOC,OAAOF,IAAd,IAAsBF,KAA/B;AACH;AACJ,iBAPD;AAQH;AACJ,SAbD;AAcH;;AAGD,KAAC,SAAIM,eAAL,EAAsB,EAACC,IAAD,EAAtB,EAA8BV,QAA9B,EAAwC;AACpC,cAAMW,UAAUD,KAAKE,MAArB;AACA,YAAIC,CAAJ;AAAA,YAAOrB,aAAakB,KAAKG,IAAI,CAAT,CAApB;AACA,cAAMC,OAAOC,SAAS;AAClB,gBAAI,EAAEF,CAAF,GAAMF,OAAV,EAAmB;AACfnB,6BAAakB,KAAKG,CAAL,CAAb;AACA,qBAAKrB,WAAWM,IAAhB,EAAsBN,UAAtB,EAAkCsB,IAAlC;AACH,aAHD,MAGO;AACHd,yBAASe,KAAT;AACH;AACJ,SAPD;AAQA,aAAKvB,WAAWM,IAAhB,EAAsBN,UAAtB,EAAkCsB,IAAlC;AACH;;AAED,KAAC,SAAIE,iBAAL,EAAwB,EAACC,IAAD,EAAOC,UAAP,EAAmBC,SAAnB,EAAxB,EAAuDnB,QAAvD,EAAiE;AAC7D,aAAKiB,KAAKnB,IAAV,EAAgBmB,IAAhB,EAAsBA,QAAQ;AAC1B,gBAAIA,IAAJ,EAAU;AACN,qBAAKC,WAAWpB,IAAhB,EAAsBoB,UAAtB,EAAkClB,QAAlC;AACH,aAFD,MAEO;AACH,qBAAKmB,UAAUrB,IAAf,EAAqBqB,SAArB,EAAgCnB,QAAhC;AACH;AACJ,SAND;AAOH;;AAED,KAAC,SAAII,UAAL,EAAiB,EAACC,IAAD,EAAjB,EAAyBL,QAAzB,EAAmC;AAC/B,cAAMe,QAAQ,KAAKrB,OAAL,CAAaW,IAAb,CAAd;AACA,YAAIU,iBAAiBnB,OAArB,EAA8B;AAC1BmB,kBAAMK,IAAN,CAAWpB,QAAX;AACH,SAFD,MAEO;AACHA,qBAASe,KAAT;AACH;AACJ;;AAED,KAAC,SAAI9B,MAAL,EAAa,EAACoC,IAAD,EAAb,EAAqBrB,QAArB,EAA+B;AAC3BA,iBAASd,KAAKmC,IAAL,CAAT;AACH;;AAED,KAAC,SAAIlC,MAAL,EAAa,EAACkC,IAAD,EAAb,EAAqBrB,QAArB,EAA+B;AAC3BA,iBAASb,OAAOkC,IAAP,CAAT;AACH;;AAED,KAAC,SAAIC,cAAL,EAAqB,EAACC,MAAD,EAASC,UAAT,EAArB,EAA2CxB,QAA3C,EAAqD;AACjD,cAAMW,UAAUa,WAAWZ,MAA3B;AACA,YAAID,OAAJ,EAAa;AACT,kBAAMc,OAAO,IAAIC,KAAJ,CAAUf,OAAV,CAAb;AACA,gBAAIE,IAAI,CAAR;AAAA,gBAAWc,YAAYH,WAAWX,CAAX,CAAvB;AACA,kBAAMC,OAAOC,SAAS;AAClBU,qBAAKZ,CAAL,IAAUE,KAAV;AACA,oBAAI,EAAEF,CAAF,GAAMF,OAAV,EAAmB;AACfgB,gCAAYH,WAAWX,CAAX,CAAZ;AACA,yBAAKc,UAAU7B,IAAf,EAAqB6B,SAArB,EAAgCb,IAAhC;AACH,iBAHD,MAGO;AACH,yBAAKS,OAAOzB,IAAZ,EAAkByB,MAAlB,EAA0B,CAACA,MAAD,EAAS5B,OAAO,KAAKA,IAArB,KAA8B;AACpD,4BAAIiC,MAAJ;AACA,4BAAI,CAACA,SAASL,OAAOM,IAAP,CAAYlC,IAAZ,EAAkB,GAAG8B,IAArB,CAAV,KAAyCG,OAAOR,IAApD,EAA0D;AACtDQ,mCAAOR,IAAP,CAAYpB,QAAZ;AACH,yBAFD,MAEO;AACHA,qCAAS4B,MAAT;AACH;AACJ,qBAPD;AAQH;AACJ,aAfD;AAgBA,iBAAKD,UAAU7B,IAAf,EAAqB6B,SAArB,EAAgCb,IAAhC;AACH,SApBD,MAoBO;AACH,iBAAKS,OAAOzB,IAAZ,EAAkByB,MAAlB,EAA0B,CAACA,MAAD,EAAS5B,OAAO,KAAKA,IAArB,KAA8B;AACpD,oBAAIiC,MAAJ;AACA,oBAAI,CAACA,SAASL,OAAOM,IAAP,CAAYlC,IAAZ,CAAV,KAAgCiC,OAAOR,IAA3C,EAAiD;AAC7CQ,2BAAOR,IAAP,CAAYpB,QAAZ;AACH,iBAFD,MAEO;AACHA,6BAAS4B,MAAT;AACH;AACJ,aAPD;AAQH;AACJ;;AAED,KAAC,SAAIE,cAAL,EAAqBC,OAArB,EAA8B/B,QAA9B,EAAwC;AACpCA,iBAAS,KAAKL,IAAd;AACH;;AAED,KAAC,SAAIqC,gBAAL,EAAuB,EAAC1B,MAAD,EAASC,MAAT,EAAiBC,QAAjB,EAAvB,EAAmDR,QAAnD,EAA6D;AACzD,aAAKM,OAAOR,IAAZ,EAAkBQ,MAAlB,EAA0BA,UAAU;AAChC,gBAAIS,KAAJ;AACA,gBAAIP,QAAJ,EAAc;AACV,qBAAKD,OAAOT,IAAZ,EAAkBS,MAAlB,EAA0BA,UAAU;AAChC,wBAAI,CAACQ,QAAQT,OAAOC,MAAP,CAAT,aAAoCX,OAAxC,EAAiD;AAC7CmB,8BAAMK,IAAN,CAAWpB,QAAX;AACH,qBAFD,MAEO;AACHA,iCAASe,KAAT,EAAgBT,MAAhB;AACH;AACJ,iBAND;AAOH,aARD,MAQO;AACH,oBAAI,CAACS,QAAQT,OAAOC,OAAOF,IAAP,IAAerB,QAAQuB,OAAOT,IAAf,EAAqBS,OAAOc,IAA5B,CAAtB,CAAT,aAA8EzB,OAAlF,EAA2F;AACvFmB,0BAAMK,IAAN,CAAWpB,QAAX;AACH,iBAFD,MAEO;AACHA,6BAASe,KAAT,EAAgBT,MAAhB;AACH;AACJ;AACJ,SAjBD;AAkBH;;AAED,KAAC,SAAI2B,eAAL,EAAsB,EAACC,QAAD,EAAtB,EAAkClC,QAAlC,EAA4C;AACxC,cAAMW,UAAUuB,SAAStB,MAAzB;AACA,YAAID,OAAJ,EAAa;AACT,kBAAMwB,QAAQ,IAAIT,KAAJ,CAAUf,OAAV,CAAd;AACA,gBAAIE,IAAI,CAAR;AAAA,gBAAWuB,UAAUF,SAASrB,CAAT,CAArB;AACA,kBAAMC,OAAOC,SAAS;AAClBoB,sBAAMtB,CAAN,IAAWE,KAAX;AACA,oBAAI,EAAEF,CAAF,GAAMF,OAAV,EAAmB;AACfyB,8BAAUF,SAASrB,CAAT,CAAV;AACA,2BAAO,KAAKuB,QAAQtC,IAAb,EAAmBsC,OAAnB,EAA4BtB,IAA5B,CAAP;AACH,iBAHD,MAGO;AACHd,6BAASmC,KAAT;AACH;AACJ,aARD;AASA,iBAAKC,QAAQtC,IAAb,EAAmBsC,OAAnB,EAA4BtB,IAA5B;AACH,SAbD,MAaO;AACHd,qBAAS,EAAT;AACH;AACJ;;AAED;;;;;;;AAOA,KAAC,SAAIqC,QAAL,EAAe,EAACC,GAAD,EAAMvB,KAAN,EAAaP,QAAb,EAAf,EAAuCR,QAAvC,EAAiD;AAC7C,aAAKe,MAAMjB,IAAX,EAAiBiB,KAAjB,EAAwBA,SAAS;AAC7B,gBAAIP,QAAJ,EAAc;AACV,qBAAK8B,IAAIxC,IAAT,EAAewC,GAAf,EAAoBA,OAAOtC,SAASsC,GAAT,EAAcvB,KAAd,CAA3B;AACH,aAFD,MAEO;AACH,uBAAOf,SAASsC,IAAIjC,IAAJ,IAAYrB,QAAQsD,IAAIxC,IAAZ,EAAkBwC,IAAIjB,IAAtB,CAArB,EAAkDN,KAAlD,CAAP;AACH;AACJ,SAND;AAOH;;AAED,KAAC,SAAIwB,gBAAL,EAAuB,EAACC,UAAD,EAAvB,EAAqCxC,QAArC,EAA+C;AAC3C,cAAMW,UAAU6B,WAAW5B,MAA3B;AACA,cAAMN,SAAS,EAAf;AACA,YAAIK,OAAJ,EAAa;AACT,gBAAIE,IAAI,CAAR;AAAA,gBAAW4B,WAAWD,WAAW3B,CAAX,CAAtB;AACA,kBAAMC,OAAO,CAACwB,GAAD,EAAMvB,KAAN,KAAgB;AACzBT,uBAAOgC,GAAP,IAAcvB,KAAd;AACA,oBAAI,EAAEF,CAAF,GAAMF,OAAV,EAAmB;AACf8B,+BAAWD,WAAW3B,CAAX,CAAX;AACA,yBAAK4B,SAAS3C,IAAd,EAAoB2C,QAApB,EAA8B3B,IAA9B;AACH,iBAHD,MAGO;AACHd,6BAASM,MAAT;AACH;AACJ,aARD;AASA,iBAAKmC,SAAS3C,IAAd,EAAoB2C,QAApB,EAA8B3B,IAA9B;AACH,SAZD,MAYO;AACHd,qBAASM,MAAT;AACH;AACJ;AAjMoB,C;;;AAoMzB,MAAMoC,mBAAoBC,SAAD,IAAe,UAAU,EAACzC,IAAD,EAAOC,KAAP,EAAcyC,QAAd,EAAV,EAAmC5C,QAAnC,EAA6C;AACjF,SAAKG,MAAML,IAAX,EAAiBK,KAAjB,EAAwBA,SAAS;AAC7B,aAAKD,KAAKJ,IAAV,EAAgBI,IAAhB,EAAsBA,QAAQF,SAAS2C,UAAUC,QAAV,EAAoB1C,IAApB,EAA0BC,KAA1B,CAAT,CAA9B;AACH,KAFD;AAGH,CAJD;;AAOA,MAAM0C,kBAAmBF,SAAD,IAAe,UAAU,EAACG,MAAD,EAASF,QAAT,EAAmBG,QAAnB,EAAV,EAAwC/C,QAAxC,EAAkD;AACrF,SAAK+C,SAASjD,IAAd,EAAoBiD,QAApB,EAA8BA,YAAY/C,SAAS2C,UAAUC,QAAV,EAAoBG,QAApB,CAAT,CAA1C;AACH,CAFD;;AAIA3D,YAAY4D,SAAZ,CAAsB,SAAIC,iBAA1B,IAA+CP,iBAAiB,qBAAUQ,OAA3B,CAA/C;AACA9D,YAAY4D,SAAZ,CAAsB,SAAIG,kBAA1B,IAAgDT,iBAAiB,qBAAUU,QAA3B,CAAhD;AACAhE,YAAY4D,SAAZ,CAAsB,SAAIK,oBAA1B,IAAkDX,iBAAiB,qBAAUY,UAA3B,CAAlD;AACAlE,YAAY4D,SAAZ,CAAsB,SAAIO,kBAA1B,IAAgDb,iBAAiB,qBAAUc,QAA3B,CAAhD;AACApE,YAAY4D,SAAZ,CAAsB,SAAIS,wBAA1B,IAAsDf,iBAAiB,qBAAUgB,cAA3B,CAAtD;AACAtE,YAAY4D,SAAZ,CAAsB,SAAIH,eAA1B,IAA6CA,gBAAgB,qBAAUc,KAA1B,CAA7C;;AAEAvE,YAAY4D,SAAZ,CAAsB,SAAIY,OAA1B,IAAqC,UAAU,EAAC7C,KAAD,EAAV,EAAmBf,QAAnB,EAA6B;AAC9DA,aAASe,KAAT;AACH,CAFD","file":"interpreter.js","sourcesContent":["import {Operators} from \"./operators.js\";\nimport {Parser} from \"./parser.js\";\nimport {AST} from \"./ast.js\";\n\nconst valueOf = {\n    [AST.String]: eval,\n    [AST.Number]: Number\n};\n\nexport class Interpreter {\n\n    constructor(parser = new Parser()) {\n        this.parser = parser;\n    }\n\n    parse(expression) {\n        this.ast = this.parser.parse(expression);\n    }\n\n    eval(context, self) {\n        this.context = context;\n        this.self = self;\n        return new Promise(resolve => this[this.ast.type](this.ast, resolve));\n    }\n\n    [AST.Expression]({expression}, callback) {\n        this[expression.type](expression, callback);\n    }\n\n    [AST.AssignmentExpression]({left, right}, callback) {\n        this[right.type](right, right => {\n            if (left.type === AST.Identifier) {\n                callback(this.context[left.name] = right);\n            } else {\n                this[left.object.type](left.object, object => {\n                    const member = left.member;\n                    if (left.computed) {\n                        this[member.type](member, member => callback(object[member] = right));\n                    } else {\n                        callback(object[member.name] = right);\n                    }\n                });\n            }\n        });\n    }\n\n\n    [AST.CommaExpression]({list}, callback) {\n        const pending = list.length;\n        let p, expression = list[p = 0];\n        const next = value => {\n            if (++p < pending) {\n                expression = list[p];\n                this[expression.type](expression, next);\n            } else {\n                callback(value);\n            }\n        };\n        this[expression.type](expression, next);\n    }\n\n    [AST.TernaryExpression]({test, consequent, alternate}, callback) {\n        this[test.type](test, test => {\n            if (test) {\n                this[consequent.type](consequent, callback);\n            } else {\n                this[alternate.type](alternate, callback);\n            }\n        });\n    }\n\n    [AST.Identifier]({name}, callback) {\n        const value = this.context[name];\n        if (value instanceof Promise) {\n            value.then(callback);\n        } else {\n            callback(value);\n        }\n    }\n\n    [AST.String]({text}, callback) {\n        callback(eval(text));\n    }\n\n    [AST.Number]({text}, callback) {\n        callback(Number(text));\n    }\n\n    [AST.CallExpression]({callee, parameters}, callback) {\n        const pending = parameters.length;\n        if (pending) {\n            const args = new Array(pending);\n            let p = 0, parameter = parameters[p];\n            const next = value => {\n                args[p] = value;\n                if (++p < pending) {\n                    parameter = parameters[p];\n                    this[parameter.type](parameter, next);\n                } else {\n                    this[callee.type](callee, (callee, self = this.self) => {\n                        let result;\n                        if ((result = callee.call(self, ...args)) && result.then) {\n                            result.then(callback);\n                        } else {\n                            callback(result);\n                        }\n                    });\n                }\n            };\n            this[parameter.type](parameter, next);\n        } else {\n            this[callee.type](callee, (callee, self = this.self) => {\n                let result;\n                if ((result = callee.call(self)) && result.then) {\n                    result.then(callback);\n                } else {\n                    callback(result);\n                }\n            });\n        }\n    }\n\n    [AST.SelfExpression](ignored, callback) {\n        callback(this.self);\n    }\n\n    [AST.MemberExpression]({object, member, computed}, callback) {\n        this[object.type](object, object => {\n            let value;\n            if (computed) {\n                this[member.type](member, member => {\n                    if ((value = object[member]) instanceof Promise) {\n                        value.then(callback)\n                    } else {\n                        callback(value, object);\n                    }\n                });\n            } else {\n                if ((value = object[member.name || valueOf[member.type](member.text)]) instanceof Promise) {\n                    value.then(callback);\n                } else {\n                    callback(value, object)\n                }\n            }\n        });\n    }\n\n    [AST.ArrayExpression]({elements}, callback) {\n        const pending = elements.length;\n        if (pending) {\n            const array = new Array(pending);\n            let p = 0, element = elements[p];\n            const next = value => {\n                array[p] = value;\n                if (++p < pending) {\n                    element = elements[p];\n                    return this[element.type](element, next);\n                } else {\n                    callback(array);\n                }\n            };\n            this[element.type](element, next);\n        } else {\n            callback([]);\n        }\n    }\n\n    /**\n     *\n     * @param key\n     * @param value\n     * @param computed not used\n     * @param callback\n     */\n    [AST.Property]({key, value, computed}, callback) {\n        this[value.type](value, value => {\n            if (computed) {\n                this[key.type](key, key => callback(key, value));\n            } else {\n                return callback(key.name || valueOf[key.type](key.text), value);\n            }\n        });\n    }\n\n    [AST.ObjectExpression]({properties}, callback) {\n        const pending = properties.length;\n        const object = {};\n        if (pending) {\n            let p = 0, property = properties[p];\n            const next = (key, value) => {\n                object[key] = value;\n                if (++p < pending) {\n                    property = properties[p];\n                    this[property.type](property, next);\n                } else {\n                    callback(object);\n                }\n            };\n            this[property.type](property, next);\n        } else {\n            callback(object);\n        }\n    }\n}\n\nconst BinaryExpression = (operators) => function ({left, right, operator}, callback) {\n    this[right.type](right, right => {\n        this[left.type](left, left => callback(operators[operator](left, right)));\n    });\n};\n\n\nconst UnaryExpression = (operators) => function ({prefix, operator, argument}, callback) {\n    this[argument.type](argument, argument => callback(operators[operator](argument)));\n};\n\nInterpreter.prototype[AST.LogicalExpression] = BinaryExpression(Operators.Logical);\nInterpreter.prototype[AST.EqualityExpression] = BinaryExpression(Operators.Equality);\nInterpreter.prototype[AST.RelationalExpression] = BinaryExpression(Operators.Relational);\nInterpreter.prototype[AST.AdditiveExpression] = BinaryExpression(Operators.Additive);\nInterpreter.prototype[AST.MultiplicativeExpression] = BinaryExpression(Operators.Multiplicative);\nInterpreter.prototype[AST.UnaryExpression] = UnaryExpression(Operators.Unary);\n\nInterpreter.prototype[AST.Literal] = function ({value}, callback) {\n    callback(value);\n};\n\n"]}