{"version":3,"sources":["../../src/main/compiler.js"],"names":["AsyncFunction","Object","getPrototypeOf","constructor","uniqueExpressionID","index","expressionMixin","BaseFunction","parameters","code","sourceURL","next","value","block","size","Array","from","bind","target","bound","toString","join","Expression","Function","AsyncExpression","Compiler","compile","source","watch","isAsync","Set","hasAwait","ast","type","expression","left","right","async","test","alternate","consequent","operator","argument","prefix","callee","args","filter","map","arg","object","property","computed","lhs","rhs","result","add","text","eval","name","local","elements","e","key","properties","p"],"mappings":"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","file":"compiler.js","sourcesContent":["import {Parser} from \"./parser\";\n\n/**\n * AsyncFunction is a constructor for asynchronous functions (same as new Function(...)).\n *\n * Similar to: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\n */\nconst AsyncFunction = Object.getPrototypeOf(async () => (void 0)).constructor;\n\nconst uniqueExpressionID = (function* () {\n    let index = 0;\n    while (true) yield `expression?id=${index++}`;\n})();\n\nfunction expressionMixin(BaseFunction) {\n\n    return class extends BaseFunction {\n\n        constructor(parameters, code, sourceURL = uniqueExpressionID.next().value) {\n\n            const block = `//# sourceURL=${ sourceURL }\\nreturn ${code}`;\n            if (parameters.size) {\n                super(...Array.from(parameters),  block);\n            } else {\n                super(block);\n            }\n            this.sourceURL = sourceURL;\n            this.parameters = parameters;\n        }\n\n        bind(target) {\n            const bound = super.bind(target);\n            bound.sourceURL = this.sourceURL;\n            bound.parameters = this.parameters;\n            return bound;\n        }\n\n        toString() {\n            return `function (${this.parameters.join(', ')}) { //# sourceURL=${this.sourceURL} ... }`;\n        }\n    }\n}\n\nexport const Expression = expressionMixin(Function);\nexport const AsyncExpression = expressionMixin(AsyncFunction);\n\nexport class Compiler {\n\n    static compile(source, sourceURL, watch) {\n        const {code, parameters, isAsync} = new Compiler().compile(source, watch);\n        if (isAsync) {\n            return new AsyncExpression(parameters, code, sourceURL);\n        } else {\n            return new Expression(parameters, code, sourceURL);\n        }\n    }\n\n    constructor() {\n        this.parameters = new Set();\n        this.hasAwait = false;\n    }\n\n    compile(source, watch) {\n        const ast = new Parser(source).ast();\n        if (watch) {\n            this.watch = watch;\n        }\n        return {\n            code: this[ast.type](ast),\n            parameters: this.parameters,\n            isAsync: this.hasAwait\n        };\n    }\n\n    ['ExpressionStatement']({expression}) {\n        return this[expression.type](expression);\n    }\n\n    ['AssignmentExpression']({left, right}) {\n        return this[left.type](left) + '=' + this[right.type](right);\n    }\n\n    ['AwaitExpression']({async}) {\n        this.hasAwait = true;\n        return '(await ' + this[async.type](async) + ')';\n    }\n\n    ['ConditionalExpression']({test, alternate, consequent}) {\n        return this[test.type](test) + '?' + this[alternate.type](alternate) + \":\" + this[consequent.type](consequent);\n    }\n\n    ['LogicalExpression']({operator, left, right}) {\n        return this[left.type](left) + operator + this[right.type](right);\n    }\n\n    ['BinaryExpression']({operator, left, right}) {\n        return this[left.type](left) + operator + this[right.type](right);\n    }\n\n    ['UnaryExpression']({operator, argument, prefix}) {\n        argument = this[argument.type](argument);\n        if (prefix) {\n            return operator + argument;\n        } else {\n            return argument + operator;\n        }\n    }\n\n    ['CallExpression']({callee, args, filter}) {\n        args = args.map(arg => this[arg.type](arg));\n        if (!filter) {\n            return this[callee.type](callee) + '(' + args + ')';\n        }\n    }\n\n    ['MemberExpression']({object, property, computed}) {\n        if (computed) {\n            let lhs = this[object.type](object);\n            let rhs = this[property.type](property);\n            const result = lhs + '[' + rhs + ']';\n            if (this.watch) {\n                this.watch.add(lhs + '.' + (property.type === 'Literal' ? property.text : eval(property.value)));\n            }\n            return result;\n        } else {\n            const result = this[object.type](object) + '.' + this[property.type](property);\n            if (this.watch) {\n                this.watch.add(result);\n            }\n            return result;\n        }\n    }\n\n    ['Identifier']({name, local}) {\n        if (!local) {\n            if (this.watch) {\n                this.watch.add(name);\n            }\n            this.parameters.add(name);\n        }\n        return name;\n    }\n\n    ['Literal']({text}) {\n        return text;\n    }\n\n    ['This']() {\n        if (this.watch) {\n            this.watch.add('this');\n        }\n        return 'this';\n    }\n\n    ['Number']({text}) {\n        return text;\n    }\n\n    ['String']({value}) {\n        return value;\n    }\n\n    ['ArrayExpression']({elements}) {\n        elements = elements.map(e => this[e.type](e));\n        return '[' + elements + ']';\n    }\n\n    ['Property']({key, value, computed}) {\n        key = this[key.type](key);\n        value = this[value.type](value);\n        if (computed) {\n            return '[' + key + ']:' + value;\n        } else {\n            return key + ':' + value;\n        }\n    }\n\n    ['ObjectExpression']({properties}) {\n        properties = properties.map(p => this[p.type](p));\n        return '{' + properties + '}';\n    }\n}\n"]}