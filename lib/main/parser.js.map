{"version":3,"sources":["../../src/main/parser.js"],"names":["Ampersand","LeftParenthesis","RightParenthesis","Comma","FullStop","Colon","EqualSign","QuestionMark","LeftSquareBracket","RightSquareBracket","LeftCurlyBracket","Pipe","RightCurlyBracket","ExclamationMark","LessThanSign","GreaterThanSign","PlusSign","MinusSign","PercentSign","Asterisk","Slash","defaultSymbols","Object","entries","reduce","symbols","name","group","keys","ParserError","Error","constructor","lexer","message","token","Parser","operatorSymbols","allSymbols","compileSymbols","parse","text","ast","type","Expression","expression","done","error","debug","comma","last","assignment","peek","list","advance","push","ternary","CommaExpression","left","right","Identifier","MemberExpression","AssignmentExpression","test","logicalOR","consequent","expect","alternate","TernaryExpression","logicalAND","consumeTwo","LogicalExpression","operator","equality","relational","consumeSymbol","EqualityExpression","additive","RelationalExpression","multiplicative","AdditiveExpression","unary","MultiplicativeExpression","UnaryExpression","prefix","argument","primary","array","object","nextToken","Literal","Literals","String","Number","CallExpression","callee","parameters","arguments","member","computed","identifier","args","undefined","consume","nextLiteral","local","elements","ArrayExpression","properties","key","value","Property","ObjectExpression"],"mappings":"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","file":"parser.js","sourcesContent":["import {Lexer} from \"./lexer.js\";\nimport {CharCode} from \"./charcodes.js\";\nimport {Tokens} from \"./language.js\";\nimport {AST} from \"./ast.js\";\nimport {Operators} from \"./operators.js\";\n\nconst {\n    Ampersand, LeftParenthesis, RightParenthesis, Comma, FullStop, Colon, EqualSign, QuestionMark, LeftSquareBracket,\n    RightSquareBracket, LeftCurlyBracket, Pipe, RightCurlyBracket, ExclamationMark, LessThanSign, GreaterThanSign,\n    PlusSign, MinusSign, PercentSign, Asterisk, Slash\n} = CharCode;\n\nconst defaultSymbols = Object.entries(Operators).reduce((symbols, [name, group]) => {\n    symbols[name] = Object.keys(group);\n    return symbols;\n}, {});\n\nexport class ParserError extends Error {\n    constructor(lexer, message) {\n        super(message);\n        this.token = lexer.token;\n    }\n}\n\nexport class Parser {\n\n    constructor(operatorSymbols) {\n        if (operatorSymbols) {\n            const allSymbols = {};\n            for (const [name, symbols] of Object.entries(operatorSymbols)) allSymbols[name] = symbols;\n            for (const [name, symbols] of Object.entries(defaultSymbols)) allSymbols[name] = symbols;\n            this.operatorSymbols = Lexer.compileSymbols(allSymbols);\n        } else {\n            this.operatorSymbols = Parser.defaultSymbols || (\n                Parser.defaultSymbols = Lexer.compileSymbols(defaultSymbols)\n            );\n        }\n    }\n\n    parse(text) {\n        const lexer = new Lexer(text, this.operatorSymbols);\n        const ast = {type: AST.Expression, expression: this.expression(lexer)};\n        if (lexer.done) {\n            lexer.error(\"Unexpected input: \" + lexer.debug(20));\n        }\n        return ast;\n    }\n\n    expression(lexer) {\n        return this.comma(lexer);\n    }\n\n    comma(lexer) {\n        let last = this.assignment(lexer);\n        if (lexer.peek === Comma) {\n            const list = [last];\n            do {\n                lexer.advance(1);\n                list.push(this.ternary(lexer));\n            } while (lexer.peek === Comma);\n            return {type: AST.CommaExpression, list};\n        }\n        return last;\n    }\n\n    assignment(lexer) {\n        const left = this.ternary(lexer);\n        if (lexer.peek === EqualSign) {\n            lexer.advance(1);\n            const right = this.assignment(lexer);\n            if (left.type === AST.Identifier || left.type === AST.MemberExpression) {\n                return {type: AST.AssignmentExpression, left, right};\n            } else {\n                throw new ParserError(lexer, `Trying to assign to a non l-value: '${left}'`);\n            }\n        } else {\n            return left;\n        }\n    }\n\n    ternary(lexer) {\n        const test = this.logicalOR(lexer);\n        if (lexer.peek === QuestionMark) {\n            lexer.advance(1);\n            const consequent = this.expression(lexer);\n            lexer.expect(Colon);\n            const alternate = this.expression(lexer);\n            return {type: AST.TernaryExpression, test, consequent, alternate};\n        }\n        return test;\n    }\n\n    logicalOR(lexer) {\n        let left = this.logicalAND(lexer);\n        while (lexer.peek === Pipe && lexer.consumeTwo(Pipe)) {\n            left = {type: AST.LogicalExpression, operator: '||', left, right: this.logicalAND(lexer)};\n        }\n        return left;\n    }\n\n    logicalAND(lexer) {\n        let left = this.equality(lexer);\n        while (lexer.peek === Ampersand && lexer.consumeTwo(Ampersand)) {\n            left = {type: AST.LogicalExpression, operator: '&&', left, right: this.equality(lexer)};\n        }\n        return left;\n    }\n\n    equality(lexer) {\n        let left = this.relational(lexer), operator;\n        while ((lexer.peek === EqualSign || lexer.peek === ExclamationMark) && (operator = lexer.consumeSymbol('Equality'))) {\n            left = {type: AST.EqualityExpression, operator, left, right: this.relational(lexer)};\n        }\n        return left;\n    }\n\n    relational(lexer) {\n        let left = this.additive(lexer), operator;\n        while ((lexer.peek === LessThanSign || lexer.peek === GreaterThanSign) && (operator = lexer.consumeSymbol('Relational'))) {\n            left = {type: AST.RelationalExpression, operator, left, right: this.additive(lexer)};\n        }\n        return left;\n    }\n\n    additive(lexer) {\n        let left = this.multiplicative(lexer), operator;\n        while ((lexer.peek === PlusSign || lexer.peek === MinusSign) && (operator = lexer.consumeSymbol('Additive'))) {\n            left = {type: AST.AdditiveExpression, operator, left, right: this.multiplicative(lexer)};\n        }\n        return left;\n    }\n\n    multiplicative(lexer) {\n        let left = this.unary(lexer), operator;\n        while ((lexer.peek === Asterisk || lexer.peek === Slash || lexer.peek === PercentSign) && (operator = lexer.consumeSymbol('Multiplicative'))) {\n            left = {type: AST.MultiplicativeExpression, operator, left, right: this.unary(lexer)};\n        }\n        return left;\n    }\n\n    unary(lexer) {\n        let operator;\n        if ((lexer.peek === PlusSign || lexer.peek === MinusSign || lexer.peek === ExclamationMark) && (operator = lexer.consumeSymbol('Unary'))) {\n            return {type: AST.UnaryExpression, prefix: true, operator, argument: this.unary(lexer)};\n        }\n        return this.primary(lexer);\n    }\n\n    primary(lexer) {\n\n        let primary;\n\n        if (lexer.peek === LeftParenthesis) {\n            lexer.advance(1);\n            primary = this.expression(lexer);\n            lexer.expect(RightParenthesis);\n        } else if (lexer.peek === LeftSquareBracket) {\n            lexer.advance(1);\n            primary = this.array(lexer);\n            lexer.expect(RightSquareBracket);\n        } else if (lexer.peek === LeftCurlyBracket) {\n            lexer.advance(1);\n            primary = this.object(lexer);\n            lexer.expect(RightCurlyBracket);\n        } else {\n            const token = lexer.nextToken();\n            switch (token.type) {\n                case Tokens.Literal:\n                    primary = AST.Literals[token.text] || {type: AST.Identifier, name: token.text};\n                    break;\n                case Tokens.String:\n                    primary = {type: AST.String, text: token.text};\n                    break;\n                case Tokens.Number:\n                    primary = {type: AST.Number, text: token.text};\n                    break;\n                default: {\n                    throw new ParserError(lexer, `Not a primary expression: ${this.token.text}`);\n                }\n            }\n        }\n\n        do if (lexer.peek === LeftParenthesis) {\n            lexer.advance(1);\n            primary = {type: AST.CallExpression, callee: primary, parameters: this.arguments(lexer)};\n            lexer.expect(RightParenthesis);\n        } else if (lexer.peek === LeftSquareBracket) {\n            lexer.advance(1);\n            primary = {type: AST.MemberExpression, object: primary, member: this.expression(lexer), computed: true};\n            lexer.expect(RightSquareBracket);\n        } else if (lexer.peek === FullStop) {\n            lexer.advance(1);\n            primary = {type: AST.MemberExpression, object: primary, member: this.identifier(lexer), computed: false};\n        } else {\n            return primary;\n        } while (true);\n    }\n\n    arguments(lexer) {\n        let args = [];\n        if (lexer.peek && lexer.peek !== RightParenthesis) do {\n            if (lexer.peek === Comma || lexer.peek === RightParenthesis) {\n                args.push(AST.Literals.undefined);\n                continue;\n            }\n            args.push(this.assignment(lexer));\n        } while (lexer.consume(Comma));\n        return args;\n    }\n\n    identifier(lexer) {\n        const token = lexer.nextLiteral();\n        if (token.type !== Tokens.Literal || AST.Literals[token.text]) {\n            throw new ParserError(lexer, `Expected <identifier> but found ${ this.token.text }`);\n        }\n        return {type: AST.Identifier, name: token.text, local: true};\n    }\n\n    array(lexer) {\n        let elements = [];\n        if (lexer.peek && lexer.peek !== RightSquareBracket) do {\n            if (lexer.peek === Comma || lexer.peek === RightSquareBracket) {\n                elements.push(AST.Literals.undefined);\n                continue;\n            }\n            elements.push(this.assignment(lexer));\n        } while (lexer.consume(Comma));\n        return {type: AST.ArrayExpression, elements};\n    }\n\n    /**\n     *\n     * @param {Lexer} lexer\n     * @return {*}\n     */\n    object(lexer) {\n\n        let properties = [], key, value, computed;\n\n        if (lexer.peek && lexer.peek !== RightCurlyBracket) do {\n\n            if (lexer.peek === Comma || lexer.peek === RightCurlyBracket) {\n                continue;\n            }\n\n            if (lexer.consume(LeftSquareBracket)) {\n                computed = true;\n                key = this.assignment(lexer);\n                lexer.expect(RightSquareBracket);\n                lexer.expect(Colon);\n                value = this.assignment(lexer);\n            } else {\n                computed = false;\n                let token = lexer.nextToken();\n                switch (token.type) {\n                    case Tokens.Number:\n                        key = {type: AST.Number, text: token.text};\n                        lexer.expect(Colon);\n                        value = this.assignment(lexer);\n                        break;\n                    case Tokens.String:\n                        key = {type: AST.String, text: token.text};\n                        lexer.expect(Colon);\n                        value = this.assignment(lexer);\n                        break;\n                    case Tokens.Literal:\n                        key = {type: AST.Identifier, name: token.text};\n                        if (lexer.consume(Colon)) {\n                            value = this.assignment(lexer);\n                        } else {\n                            value = key;\n                        }\n                        break;\n                    default:\n                        throw new ParserError(lexer, `Invalid key: '${token.text}'`);\n                }\n            }\n\n            properties.push({type: AST.Property, key, value, computed});\n\n        } while (lexer.consume(Comma));\n\n        return {type: AST.ObjectExpression, properties};\n    }\n}\n"]}