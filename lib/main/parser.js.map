{"version":3,"sources":["../../src/main/parser.js"],"names":["Ampersand","LeftParenthesis","RightParenthesis","Comma","FullStop","Colon","EqualSign","QuestionMark","LeftSquareBracket","RightSquareBracket","LeftCurlyBracket","Pipe","RightCurlyBracket","defaultSymbols","compileSymbols","ParserError","Error","constructor","lexer","message","token","Parser","lexerSymbols","Object","assign","parse","text","ast","parseExpression","done","input","source","substring","position","Math","min","length","line","column","Expression","parseComma","assignment","parseAssignment","consume","expressions","push","parseTernary","CommaExpression","ternary","right","write","AssignmentExpression","test","parseLogicalOR","consequent","expect","alternate","TernaryExpression","left","parseLogicalAND","operator","consumeTwo","BinaryExpression","parseEquality","parseRelational","consumeSymbol","parseAdditive","parseMultiplicative","parseUnary","UnaryExpression","parsePrimary","primary","parseArray","parseObject","nextToken","type","Literal","Literals","Identifier","String","Constant","Number","CallExpression","parseArguments","MemberExpression","parseIdentifier","cc","args","advance","nextLiteral","elements","ArrayExpression","properties","key","value","computed","Property","ObjectExpression"],"mappings":"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","file":"parser.js","sourcesContent":["import {Lexer} from \"./lexer.js\"\nimport {CharCode} from \"./charcodes.js\";\nimport {Tokens, Symbols} from \"./language.js\";\nimport {AST} from \"./ast.js\";\n\nconst {\n    Ampersand, LeftParenthesis, RightParenthesis, Comma, FullStop, Colon, EqualSign, QuestionMark, LeftSquareBracket,\n    RightSquareBracket, LeftCurlyBracket, Pipe, RightCurlyBracket\n} = CharCode;\n\nconst defaultSymbols = Lexer.compileSymbols(Symbols);\n\nexport class ParserError extends Error {\n    constructor(lexer, message) {\n        super(message);\n        this.token = lexer.token;\n    }\n}\n\nexport class Parser {\n\n    constructor(lexerSymbols) {\n        if (lexerSymbols) {\n            this.lexerSymbols = Lexer.compileSymbols(Object.assign({}, defaultSymbols, lexerSymbols));\n        } else {\n            this.lexerSymbols = defaultSymbols;\n        }\n    }\n\n    parse(text) {\n        const lexer = new Lexer(text, this.lexerSymbols);\n        const ast = this.parseExpression(lexer);\n        if (lexer.done) {\n            const input = lexer.source.substring(lexer.position, Math.min(lexer.position + 10, lexer.source.length));\n            const line = lexer.line;\n            const column = lexer.column;\n            throw new ParserError(lexer, `Unexpected input: ${input}... at line: ${line}, column: ${column}`);\n        }\n        return ast;\n    }\n\n    parseExpression(lexer) {\n        return new AST.Expression(this.parseComma(lexer));\n    }\n\n    parseComma(lexer) {\n        let assignment = this.parseAssignment(lexer);\n        if (lexer.consume(Comma)) {\n            const expressions = [assignment];\n            do {\n                expressions.push(this.parseTernary(lexer));\n            } while (lexer.consume(Comma));\n            return new AST.CommaExpression(expressions);\n        }\n        return assignment;\n    }\n\n    parseAssignment(lexer) {\n        const ternary = this.parseTernary(lexer);\n        if (lexer.consume(EqualSign)) {\n            const right = this.parseAssignment(lexer);\n            if (ternary.write) {\n                return new AST.AssignmentExpression(ternary, right);\n            } else {\n                throw new ParserError(lexer, `Trying to assign to a non l-value: '${ternary}'`);\n            }\n        } else {\n            return ternary;\n        }\n    }\n\n    parseTernary(lexer) {\n        const test = this.parseLogicalOR(lexer);\n        if (lexer.consume(QuestionMark)) {\n            const consequent = this.parseExpression(lexer);\n            lexer.expect(Colon);\n            const alternate = this.parseExpression(lexer);\n            return new AST.TernaryExpression({test: test, consequent: consequent, alternate: alternate});\n        }\n        return test;\n    }\n\n\n    parseLogicalOR(lexer) {\n        let left = this.parseLogicalAND(lexer), operator;\n        while (operator = lexer.consumeTwo(Pipe)) {\n            left = new AST.BinaryExpression(operator, left, this.parseLogicalAND(lexer));\n        }\n        return left;\n    }\n\n    parseLogicalAND(lexer) {\n        let left = this.parseEquality(lexer), operator;\n        while (operator = lexer.consumeTwo(Ampersand)) {\n            left = new AST.BinaryExpression(operator, left, this.parseEquality(lexer));\n        }\n        return left;\n    }\n\n    parseEquality(lexer) {\n        let left = this.parseRelational(lexer), operator;\n        while (operator = lexer.consumeSymbol('equality')) {\n            left = new AST.BinaryExpression(operator, left, this.parseRelational(lexer));\n        }\n        return left;\n    }\n\n    parseRelational(lexer) {\n        let left = this.parseAdditive(lexer), operator;\n        while (operator = lexer.consumeSymbol('relational')) {\n            left = new AST.BinaryExpression(operator, left, this.parseAdditive(lexer));\n        }\n        return left;\n    }\n\n    parseAdditive(lexer) {\n        let left = this.parseMultiplicative(lexer), operator;\n        while (operator = lexer.consumeSymbol('additive')) {\n            left = new AST.BinaryExpression(operator, left, this.parseMultiplicative(lexer));\n        }\n        return left;\n    }\n\n    parseMultiplicative(lexer) {\n        let left = this.parseUnary(lexer), operator;\n        while (operator = lexer.consumeSymbol('multiplicative')) {\n            left = new AST.BinaryExpression(operator, left, this.parseUnary(lexer));\n        }\n        return left;\n    }\n\n    parseUnary(lexer) {\n        let operator = lexer.consumeSymbol('unary');\n        if (operator) {\n            return new AST.UnaryExpression(operator, true, this.parseUnary(lexer));\n        }\n        return this.parsePrimary(lexer);\n    }\n\n    parsePrimary(lexer) {\n\n        let primary;\n\n        if (lexer.consume(LeftParenthesis)) {\n            primary = this.parseExpression(lexer);\n            lexer.expect(RightParenthesis);\n        } else if (lexer.consume(LeftSquareBracket)) {\n            primary = this.parseArray(lexer);\n            lexer.expect(RightSquareBracket);\n        } else if (lexer.consume(LeftCurlyBracket)) {\n            primary = this.parseObject(lexer);\n            lexer.expect(RightCurlyBracket);\n        } else {\n            const token = lexer.nextToken();\n            switch (token.type) {\n                case Tokens.Literal:\n                    primary = AST.Literals[token.text] || new AST.Identifier(token.text);\n                    break;\n                case Tokens.String:\n                    primary = new AST.Constant(String, token.text);\n                    break;\n                case Tokens.Number:\n                    primary = new AST.Constant(Number, token.text);\n                    break;\n                default: {\n                    throw new ParserError(lexer, `Not a primary expression: ${this.token.text}`);\n                }\n            }\n        }\n\n        do if (lexer.consume(LeftParenthesis)) {\n            primary = new AST.CallExpression(primary, this.parseArguments(lexer));\n            lexer.expect(RightParenthesis);\n        } else if (lexer.consume(LeftSquareBracket)) {\n            primary = new AST.MemberExpression(primary, this.parseExpression(lexer), true);\n            lexer.expect(RightSquareBracket);\n        } else if (lexer.consume(FullStop)) {\n            primary = new AST.MemberExpression(primary, this.parseIdentifier(lexer), false);\n        } else {\n            return primary;\n        } while (true);\n    }\n\n    parseArguments(lexer) {\n        let cc, args = [];\n        if ((cc = lexer.advance()) && cc !== RightParenthesis) do {\n            args.push(this.parseExpression(lexer));\n        } while (lexer.consume(Comma));\n        return args;\n    }\n\n    parseIdentifier(lexer) {\n        const token = lexer.nextLiteral();\n        if (token.type !== Tokens.Literal || AST.Literals[token.text]) {\n            throw new ParserError(lexer, `Expected <identifier> but found ${ this.token.text }`);\n        }\n        return new AST.Identifier(token.text, true);\n    }\n\n    parseArray(lexer) {\n        let cc, elements = [];\n        if ((cc = lexer.advance()) && cc !== RightSquareBracket) do {\n            elements.push(this.parseAssignment(lexer));\n        } while (lexer.consume(Comma));\n        return new AST.ArrayExpression(elements);\n    }\n\n    /**\n     *\n     * @param {Lexer} lexer\n     * @return {*}\n     */\n    parseObject(lexer) {\n\n        let cc, properties = [], key, value, computed;\n\n        if ((cc = lexer.advance()) && cc !== RightCurlyBracket) do {\n\n            if (lexer.consume(LeftSquareBracket)) {\n                computed = true;\n                key = this.parseAssignment(lexer);\n                lexer.expect(RightSquareBracket);\n                lexer.expect(Colon);\n                value = this.parseAssignment(lexer);\n            } else {\n                computed = false;\n                let token = lexer.nextToken();\n                switch (token.type) {\n                    case Tokens.Number:\n                        key = new AST.Constant(Number, token.text);\n                        lexer.expect(Colon);\n                        value = this.parseAssignment(lexer);\n                        break;\n                    case Tokens.String:\n                        key = new AST.Constant(String, token.text);\n                        lexer.expect(Colon);\n                        value = this.parseAssignment(lexer);\n                        break;\n                    case Tokens.Literal:\n                        key = new AST.Identifier(token.text);\n                        if (lexer.consume(Colon)) {\n                            value = this.parseAssignment(lexer);\n                        } else {\n                            value = key;\n                        }\n                        break;\n                    default:\n                        throw new ParserError(lexer, `Invalid key: '${token.text}'`);\n                }\n            }\n\n            properties.push(new AST.Property(key, value, computed));\n\n        } while (lexer.consume(Comma));\n\n        return new AST.ObjectExpression(properties);\n    }\n}\n\n"]}