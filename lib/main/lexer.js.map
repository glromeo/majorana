{"version":3,"sources":["../../src/main/lexer.js"],"names":["NewLine","Tab","Space","QuotationMark","DollarSign","Apostrophe","Asterisk","PlusSign","MinusSign","FullStop","Slash","DigitZero","DigitOne","DigitEight","DigitNine","CapitalA","CapitalB","CapitalE","CapitalF","CapitalX","CapitalZ","Backslash","LowLine","LetterA","LetterB","LetterE","LetterF","LetterX","LetterZ","Tilde","NBSP","defaultSymbols","compileSymbols","Lexer","constructor","source","arguments","charCodeAt","String","prototype","bind","position","peek","advance","symbols","__all__","cache","Map","scan","Symbol","iterator","lexer","value","undefined","done","next","nextToken","cursor","end","cc","line","column","error","message","out","debug","Error","stack","split","filter","index","join","offset","close","nextNumber","nextDecimal","nextLiteral","nextString","cc2","nextSymbol","JSON","stringify","fromCharCode","provideToken","Number","lastCharCode","provideLiteral","quote","escape","text","token","get","set","type","length","to","substring","Literal","consume","expect","expected","actual","charAt","consumeTwo","consumeThree","consumeText","p","consumeSymbol","name","expectText","from","Math","min","slice","Tokenizer","Array","symbol","Object","create","enumerable","definitions","concat","values","key","entries","ast","t","c","has","vars","Function","generateBody","tab","statement","node","condition","size","hasOwnProperty","shift"],"mappings":"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","file":"lexer.js","sourcesContent":["import {CharCode} from \"./charcodes.js\";\nimport {Symbols, Tokens} from \"./language.js\";\n\nconst {\n    NewLine, Tab, Space, QuotationMark, DollarSign, Apostrophe, Asterisk, PlusSign, MinusSign, FullStop, Slash,\n    DigitZero, DigitOne, DigitEight, DigitNine, CapitalA, CapitalB, CapitalE, CapitalF, CapitalX, CapitalZ,\n    Backslash, LowLine, LetterA, LetterB, LetterE, LetterF, LetterX, LetterZ, Tilde, NBSP\n} = CharCode;\n\nconst defaultSymbols = compileSymbols(Symbols);\n\n/**\n *\n */\nexport class Lexer {\n\n    constructor() {\n        this.source = typeof arguments[0] === \"string\" ? arguments[0] : '';\n        this.charCodeAt = String.prototype.charCodeAt.bind(this.source);\n        this.position = 0;\n        this.peek = this.advance();\n        this.symbols = arguments[1] || arguments[0] || defaultSymbols;\n        if (!this.symbols.__all__) {\n            this.symbols = compileSymbols(this.symbols);\n        }\n        this.cache = new Map();\n    }\n\n    scan(source = this.source) {\n        this.source = source;\n        this.charCodeAt = String.prototype.charCodeAt.bind(source);\n        this.position = 0;\n        this.peek = this.advance();\n        return this;\n    }\n\n    [Symbol.iterator]() {\n        const lexer = this;\n        return {\n            value: undefined,\n            done: false,\n            next() {\n                this.done = !(this.value = lexer.nextToken());\n                return this;\n            }\n        };\n    }\n\n    static cursor(source, end) {\n        let cc, position = 0, line = 1, column = 1;\n        while (position < end && (cc = source.charCodeAt(position++))) if (cc === NewLine) {\n            line++;\n            column = 1;\n        } else if (cc === Tab) {\n            column += 4;\n        } else {\n            column++;\n        }\n        return {line, column};\n    }\n\n    cursor() {\n        return Lexer.cursor(this.source, this.position);\n    }\n\n    error(message, position = this.position) {\n\n        let out = message;\n\n        if (Lexer.debug) out = \"Given: `\" + this.source + \"` \" + out;\n\n        const {line, column} = Lexer.cursor(this.source, position);\n        out += \", at line: \" + line + \", column: \" + column + \".\";\n\n        const error = new Error(out);\n        error.stack = error.stack.split(\"\\n\").filter((line, index) => index !== 1).join(\"\\n\");\n        throw error;\n    }\n\n    /**\n     * Consumes all whitespaces and comments. Stops at the first character of a valid token.\n     *\n     * @returns {Number} the first non whitespace non comment charcode\n     */\n    advance(offset) {\n\n        const charCodeAt = this.charCodeAt;\n        let cc, position = offset ? this.position + offset : this.position;\n\n        while ((cc = charCodeAt(position)) <= Space || cc === Slash || Tilde < cc && cc < NBSP) {\n\n            if (cc === Slash) {\n                if ((cc = charCodeAt(position + 1)) === Slash) {\n\n                    position++;\n\n                    while ((cc = charCodeAt(++position)) && cc !== NewLine) /* ... */;\n\n                    continue;\n\n                } else if (cc === Asterisk) {\n\n                    position++;\n\n                    while (cc = charCodeAt(++position)) if (Asterisk === cc && Slash === charCodeAt(position + 1)) {\n                        position += 2;\n                        break;\n                    }\n\n                    if (cc) continue; else this.error('Comment not closed', position);\n\n                } else {\n                    this.position = position;\n                    return this.peek = Slash;\n                }\n            }\n\n            position++;\n        }\n\n        this.position = position;\n        return this.peek = cc;\n    }\n\n    nextToken() {\n\n        let cc = this.peek || this.advance();\n        if (!cc) {\n            return this.close();\n        }\n\n        if (cc === DigitZero) {\n            return this.nextNumber();\n        }\n\n        if (cc > DigitZero && cc <= DigitNine) {\n            return this.nextDecimal();\n        }\n\n        if (cc === LowLine || cc === DollarSign || cc >= LetterA && cc <= LetterZ || cc >= CapitalA && cc <= CapitalZ) {\n            return this.nextLiteral();\n        }\n\n        if (cc === Apostrophe || cc === QuotationMark) {\n            return this.nextString(cc);\n        }\n\n        if (cc === FullStop) {\n            let cc2 = this.charCodeAt(this.position + 1);\n            if (cc2 >= DigitZero && cc2 <= DigitNine) {\n                return this.nextDecimal(FullStop);\n            }\n        }\n\n        return this.nextSymbol(cc) || this.error(`Unexpected character: ${JSON.stringify(String.fromCharCode(cc))}`);\n    }\n\n    nextNumber() {\n\n        const charCodeAt = this.charCodeAt;\n        let cc, position = this.position, cc2 = charCodeAt(++position);\n\n        if (cc2 === LetterX || cc2 === CapitalX) {\n            while ((cc = charCodeAt(++position)) && (\n                cc >= DigitZero && cc <= DigitNine || cc >= LetterA && cc <= LetterF || cc >= CapitalA && cc <= CapitalF\n            )) /* ... */;\n        } else if (cc2 === LetterB || cc2 === CapitalB) {\n            while ((cc = charCodeAt(++position)) && (\n                cc >= DigitZero && cc <= DigitOne\n            )) /* ... */;\n        } else if (cc2 >= DigitZero && cc2 < DigitEight) {\n            while ((cc = charCodeAt(++position)) && (\n                cc >= DigitZero && cc < DigitEight\n            )) /* ... */;\n        } else {\n            return this.nextDecimal();\n        }\n\n        return this.provideToken(Tokens.Number, position);\n    }\n\n    nextDecimal(lastCharCode) {\n\n        const charCodeAt = this.charCodeAt;\n        let cc = lastCharCode, position = this.position;\n\n        if (cc !== FullStop) {\n            while ((cc = charCodeAt(++position)) && (cc >= DigitZero && cc <= DigitNine)) /* ignored */;\n        }\n\n        if (cc === FullStop) {\n            while ((cc = charCodeAt(++position)) && (cc >= DigitZero && cc <= DigitNine)) ;\n        }\n\n        if (cc === LetterE || cc === CapitalE) {\n            if ((cc = charCodeAt(position + 1)) === PlusSign || cc === MinusSign) position++;\n\n            while ((cc = charCodeAt(++position)) && (cc >= DigitZero && cc <= DigitNine)) ;\n        }\n\n        return this.provideToken(Tokens.Number, position);\n    }\n\n    nextLiteral() {\n        const charCodeAt = this.charCodeAt;\n        let cc, position = this.position;\n\n        while ((cc = charCodeAt(++position)) && (\n            cc >= LetterA && cc <= LetterZ || cc >= CapitalA && cc <= CapitalZ ||\n            cc >= DigitZero && cc <= DigitNine ||\n            cc === LowLine || cc === DollarSign\n        )) ;\n\n        return this.provideLiteral(position);\n    }\n\n    nextString(quote) {\n        const charCodeAt = this.charCodeAt;\n        let cc, position = this.position, escape = false;\n\n        while (cc = charCodeAt(++position)) if (escape) {\n            escape = false;\n        } else if (cc === Backslash) {\n            escape = true;\n        } else if (cc === quote) {\n            return this.provideToken(Tokens.String, position + 1);\n        } else if (cc === NewLine) {\n            break;\n        }\n\n        this.error('String literal not closed', position);\n    }\n\n    nextSymbol(cc) {\n        const text = this.symbols.__all__(cc, this.position, this.charCodeAt);\n        if (text) {\n            let token = this.cache.get(text);\n            if (!token) {\n                this.cache.set(text, token = {type: Tokens.Symbol, text: text});\n            }\n            this.peek = this.advance(text.length);\n            return token;\n        }\n    }\n\n    provideLiteral(to) {\n        const text = this.source.substring(this.position, to);\n        let token = this.cache.get(text);\n        if (!token) {\n            this.cache.set(text, token = {type: Tokens.Literal, text: text});\n        }\n        this.peek = this.advance(text.length);\n        return token;\n    }\n\n    /* TODO: is position useful? is it a waste of CPU? */\n\n    provideToken(type, to) {\n        const text = this.source.substring(this.position, to);\n        const token = {type: type, text: text, position: this.position};\n        this.peek = this.advance(text.length);\n        return token;\n    }\n\n    consume(cc) {\n        if (cc === this.peek) {\n            this.peek = this.advance(1);\n            return true;\n        }\n    }\n\n    expect(cc) {\n        if (cc === this.peek) {\n            this.peek = this.advance(1);\n        } else {\n            let expected = String.fromCharCode(cc);\n            let actual = this.source.charAt(this.position);\n            this.error(`Expected ${ expected } but was ${ actual }`);\n        }\n    }\n\n    consumeTwo(cc) {\n        if (cc === this.peek && cc === this.charCodeAt(this.position + 1)) {\n            this.peek = this.advance(2);\n            return true;\n        }\n    }\n\n    consumeThree(cc) {\n        if (cc === this.peek && cc === this.charCodeAt(this.position + 1) && cc === this.charCodeAt(this.position + 2)) {\n            this.peek = this.advance(3);\n            return true;\n        }\n    }\n\n    consumeText(text) {\n\n        if (!this.advance()) return false;\n\n        let p = text.length;\n\n        while (p--) if (this.charCodeAt(this.position + p) !== text.charCodeAt(p)) {\n            return false\n        }\n\n        this.peek = this.advance(text.length);\n        return text;\n    }\n\n    consumeSymbol(name = '__all__') {\n        let text, consume;\n        if (consume = this.symbols[name]) {\n            if (text = consume(this.peek, this.position, this.charCodeAt)) {\n                this.peek = this.advance(text.length);\n                return text;\n            }\n        } else {\n            throw new Error(\"No lexer symbols for '\" + name + \"'\");\n        }\n    }\n\n    expectText(text) {\n        if (!this.consumeText(text)) {\n            this.error(`Expected ${\n                JSON.stringify(text)\n                } but was ${\n                JSON.stringify(this.source.substring(this.position, from + 1))\n                }`\n            );\n        }\n    }\n\n    debug(length) {\n        let from = this.position, to = Math.min(from + length, this.source.length);\n        let substring = \"`\" + this.source.slice(from, length) + \"`\";\n        return to < this.source.length ? substring + \"...\" : substring;\n    }\n\n    get done() {\n        return this.position < this.source.length;\n    }\n\n    close() {\n        this.position = this.source.length;\n        this.peek = this.advance();\n    }\n}\n\n/**\n *\n */\nexport class Tokenizer extends Lexer {\n\n    scan(source) {\n        return Array.from(super.scan(source));\n    }\n\n    nextSymbol(cc) {\n        const from = this.position;\n        let symbol = super.nextSymbol(cc);\n        return symbol && Object.create(symbol, {\n            position: {enumerable: false, value: from},\n            cursor: {enumerable: false, value: Lexer.cursor.bind(null, this.source, from)}\n        });\n    }\n\n    provideLiteral(to) {\n        const from = this.position;\n        return Object.create(super.provideLiteral(to), {\n            position: {enumerable: false, value: from},\n            cursor: {enumerable: false, value: Lexer.cursor.bind(null, this.source, from)}\n        });\n    }\n\n    provideToken(type, to) {\n        const from = this.position;\n        return Object.create(super.provideToken(type, to), {\n            position: {enumerable: false, value: from},\n            cursor: {enumerable: false, value: Lexer.cursor.bind(null, this.source, from)}\n        });\n    }\n}\n\nLexer.compileSymbols = compileSymbols;\n\n/**\n *\n * @param definitions\n * @return {*}\n */\nfunction compileSymbols(definitions) {\n\n    const symbols = {};\n\n    let __all__ = [['__all__', Array.prototype.concat(...Object.values(definitions))]];\n\n    for (const [key, value] of Object.entries(definitions).concat(__all__)) {\n\n        const ast = new Map();\n\n        for (const text of value) {\n            let t = ast, cc, c = 0;\n            while (cc = text.charCodeAt(c++)) {\n                if (!t.has(cc)) {\n                    t.set(cc, new Map());\n                }\n                t = t.get(cc);\n            }\n            t.symbol = text;\n        }\n\n        const vars = [\"c0\"];\n        vars.get = function (index) {\n            return this[index] || \"(\" + (this[index] = \"c\" + index) + \" = cc(cp + \" + index + \"))\";\n        };\n\n        symbols[key] = new Function(\"c0\", \"cp\", \"cc\",\n            `${generateBody(ast, vars)}//# sourceURL=http://majorana/lexer/${key}`\n        );\n    }\n\n    return symbols;\n}\n\nfunction generateBody(ast, vars, tab = '\\t', index = 0) {\n\n    let statement = '';\n\n    for (let [cc, node] of ast) {\n        let next = index + 1;\n        let condition = vars.get(index) + \" === \" + cc;\n        while (node.size === 1 && !node.hasOwnProperty('symbol')) {\n            [cc, node] = node.entries().next().value;\n            condition += \" && \" + vars.get(next++) + \" === \" + cc;\n        }\n        if (node.size > 1 || node.size === 1 && node.hasOwnProperty('symbol')) {\n            statement += tab + \"if (\" + condition + \") {\\n\" + generateBody(node, vars, tab + '  ', next) + tab + \"}\\n\";\n        } else {\n            statement += tab + \"if (\" + condition + \") \" + generateBody(node, vars, '', next);\n        }\n    }\n\n    if (ast.hasOwnProperty('symbol')) {\n        statement += tab + \"return \" + JSON.stringify(ast.symbol) + \";\\n\";\n    }\n\n    if (index === 0) {\n        if (vars.length > 1) {\n            vars.shift();\n            return tab + \"let \" + vars.join(\", \") + \";\\n\" + statement;\n        }\n    }\n\n    return statement;\n}"]}