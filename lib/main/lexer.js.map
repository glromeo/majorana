{"version":3,"sources":["../../src/main/lexer.js"],"names":["NewLine","Tab","Space","QuotationMark","DollarSign","Apostrophe","Asterisk","PlusSign","MinusSign","FullStop","Slash","DigitZero","DigitOne","DigitEight","DigitNine","CapitalA","CapitalB","CapitalE","CapitalF","CapitalX","CapitalZ","Backslash","LowLine","LetterA","LetterB","LetterE","LetterF","LetterX","LetterZ","Tilde","NBSP","defaultSymbols","compileSymbols","Lexer","constructor","source","arguments","charCodeAt","String","prototype","bind","position","cc","symbols","__all__","cache","Map","scan","Symbol","iterator","lexer","value","undefined","done","next","nextToken","cursor","end","line","column","error","message","Error","substring","stack","split","filter","index","join","advance","close","nextNumber","nextDecimal","nextLiteral","nextString","cc2","nextSymbol","JSON","stringify","fromCharCode","provideToken","Number","provideLiteral","quote","escape","text","token","get","set","type","length","to","Literal","consume","expect","charAt","consumeTwo","consumeThree","consumeText","p","consumeSymbol","name","expectText","from","Tokenizer","Array","symbol","Object","create","enumerable","definitions","concat","values","key","entries","ast","t","c","has","vars","Function","generateBody","tab","statement","node","condition","size","hasOwnProperty","shift"],"mappings":";;;;;;;AAAA;;AACA;;AAEA,MAAM;AACFA,WADE,EACOC,GADP,EACYC,KADZ,EACmBC,aADnB,EACkCC,UADlC,EAC8CC,UAD9C,EAC0DC,QAD1D,EACoEC,QADpE,EAC8EC,SAD9E,EACyFC,QADzF,EACmGC,KADnG;AAEFC,aAFE,EAESC,QAFT,EAEmBC,UAFnB,EAE+BC,SAF/B,EAE0CC,QAF1C,EAEoDC,QAFpD,EAE8DC,QAF9D,EAEwEC,QAFxE,EAEkFC,QAFlF,EAE4FC,QAF5F;AAGFC,aAHE,EAGSC,OAHT,EAGkBC,OAHlB,EAG2BC,OAH3B,EAGoCC,OAHpC,EAG6CC,OAH7C,EAGsDC,OAHtD,EAG+DC,OAH/D,EAGwEC,KAHxE,EAG+EC;AAH/E,uBAAN;;AAMA,MAAMC,iBAAiBC,iCAAvB;;AAEA;;;IAGaC,K,WAAAA,K,GAAN,MAAMA,KAAN,CAAY;;AAEfC,kBAAc;AACV,aAAKC,MAAL,GAAc,OAAOC,UAAU,CAAV,CAAP,KAAwB,QAAxB,GAAmCA,UAAU,CAAV,CAAnC,GAAkD,EAAhE;AACA,aAAKC,UAAL,GAAkBC,OAAOC,SAAP,CAAiBF,UAAjB,CAA4BG,IAA5B,CAAiC,KAAKL,MAAtC,CAAlB;AACA,aAAKM,QAAL,GAAgB,CAAhB;AACA,aAAKC,EAAL,GAAU,IAAV;AACA,aAAKC,OAAL,GAAeP,UAAU,CAAV,KAAgBA,UAAU,CAAV,CAAhB,IAAgCL,cAA/C;AACA,YAAI,CAAC,KAAKY,OAAL,CAAaC,OAAlB,EAA2B;AACvB,iBAAKD,OAAL,GAAeX,eAAe,KAAKW,OAApB,CAAf;AACH;AACD,aAAKE,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACH;;AAEDC,SAAKZ,SAAS,KAAKA,MAAnB,EAA2B;AACvB,aAAKA,MAAL,GAAcA,MAAd;AACA,aAAKE,UAAL,GAAkBC,OAAOC,SAAP,CAAiBF,UAAjB,CAA4BG,IAA5B,CAAiCL,MAAjC,CAAlB;AACA,aAAKM,QAAL,GAAgB,CAAhB;AACA,aAAKC,EAAL,GAAU,IAAV;AACA,eAAO,IAAP;AACH;;AAED,KAACM,OAAOC,QAAR,IAAoB;AAChB,cAAMC,QAAQ,IAAd;AACA,eAAO;AACHC,mBAAOC,SADJ;AAEHC,kBAAM,KAFH;AAGHC,mBAAO;AACH,qBAAKD,IAAL,GAAY,EAAE,KAAKF,KAAL,GAAaD,MAAMK,SAAN,EAAf,CAAZ;AACA,uBAAO,IAAP;AACH;AANE,SAAP;AAQH;;AAED,WAAOC,MAAP,CAAcrB,MAAd,EAAsBsB,GAAtB,EAA2B;AACvB,YAAIf,EAAJ;AAAA,YAAQD,WAAW,CAAnB;AAAA,YAAsBiB,OAAO,CAA7B;AAAA,YAAgCC,SAAS,CAAzC;AACA,eAAOlB,WAAWgB,GAAX,KAAmBf,KAAKP,OAAOE,UAAP,CAAkBI,UAAlB,CAAxB,CAAP,EAA+D,IAAIC,OAAO1C,OAAX,EAAoB;AAC/E0D;AACAC,qBAAS,CAAT;AACH,SAH8D,MAGxD,IAAIjB,OAAOzC,GAAX,EAAgB;AACnB0D,sBAAU,CAAV;AACH,SAFM,MAEA;AACHA;AACH;AACD,eAAO,EAACD,IAAD,EAAOC,MAAP,EAAP;AACH;;AAEDH,aAAS;AACL,eAAOvB,MAAMuB,MAAN,CAAa,KAAKrB,MAAlB,EAA0B,KAAKM,QAA/B,CAAP;AACH;;AAEDmB,UAAMC,OAAN,EAAepB,WAAW,KAAKA,QAA/B,EAAyC;AACrC,cAAM,EAACiB,IAAD,EAAOC,MAAP,KAAiB1B,MAAMuB,MAAN,CAAa,KAAKrB,MAAlB,EAA0BM,QAA1B,CAAvB;AACA,cAAMmB,QAAQ,IAAIE,KAAJ,CAAW,2BACrB,KAAK3B,MAAL,CAAY4B,SAAZ,CAAsB,CAAtB,EAAyBtB,QAAzB,IAAqC,UAArC,GAAkD,KAAKN,MAAL,CAAY4B,SAAZ,CAAsBtB,QAAtB,CACrD,qBAAqBoB,OAAS,sBAAsBH,IAAM,4BAA4BC,MAAQ,UAFjF,CAAd;AAGAC,cAAMI,KAAN,GAAcJ,MAAMI,KAAN,CAAYC,KAAZ,CAAkB,IAAlB,EAAwBC,MAAxB,CAA+B,CAACR,IAAD,EAAOS,KAAP,KAAiBA,QAAQ,CAAxD,EAA2DC,IAA3D,CAAgE,IAAhE,CAAd;AACA,cAAMR,KAAN;AACH;;AAED;;;;;AAKAS,cAAU;;AAEN,cAAMhC,aAAa,KAAKA,UAAxB;AACA,YAAIK,EAAJ;AAAA,YAAQD,WAAW,KAAKA,QAAxB;;AAEA,eAAO,CAACC,KAAKL,WAAWI,QAAX,CAAN,KAA+BvC,KAA/B,IAAwCwC,OAAOhC,KAA/C,IAAwDmB,QAAQa,EAAR,IAAcA,KAAKZ,IAAlF,EAAwF;;AAEpF,gBAAIY,OAAOhC,KAAX,EAAkB,IAAI,CAACgC,KAAKL,WAAWI,WAAW,CAAtB,CAAN,MAAoC/B,KAAxC,EAA+C;;AAE7D+B;;AAEA,uBAAO,CAACC,KAAKL,WAAW,EAAEI,QAAb,CAAN,KAAiCC,OAAO1C,OAA/C,EAAwD,SAAS;;AAEjE;AAEH,aARiB,MAQX,IAAI0C,OAAOpC,QAAX,EAAqB;;AAExBmC;;AAEA,uBAAOC,KAAKL,WAAW,EAAEI,QAAb,CAAZ,EAAoC,IAAInC,aAAaoC,EAAb,IAAmBhC,UAAU2B,WAAWI,WAAW,CAAtB,CAAjC,EAA2D;AAC3FA,gCAAY,CAAZ;AACA;AACH;;AAED,oBAAIC,EAAJ,EAAQ,SAAR,KAAuB,KAAKkB,KAAL,CAAW,oBAAX,EAAiCnB,QAAjC;AAE1B,aAXM,MAWA;AACH,qBAAKA,QAAL,GAAgBA,QAAhB;AACA,uBAAO,KAAKC,EAAL,GAAUhC,KAAjB;AACH;;AAED+B;AACH;;AAED,aAAKA,QAAL,GAAgBA,QAAhB;AACA,eAAO,KAAKC,EAAL,GAAUA,EAAjB;AACH;;AAEDa,gBAAY;;AAER,YAAIb,KAAK,KAAKA,EAAL,IAAW,KAAK2B,OAAL,EAApB;AACA,YAAI,CAAC3B,EAAL,EAAS;AACL,mBAAO,KAAK4B,KAAL,EAAP;AACH;;AAED,YAAI5B,OAAO/B,SAAX,EAAsB;AAClB,mBAAO,KAAK4D,UAAL,EAAP;AACH;;AAED,YAAI7B,KAAK/B,SAAL,IAAkB+B,MAAM5B,SAA5B,EAAuC;AACnC,mBAAO,KAAK0D,WAAL,EAAP;AACH;;AAED,YAAI9B,OAAOpB,OAAP,IAAkBoB,OAAOtC,UAAzB,IAAuCsC,MAAMnB,OAAN,IAAiBmB,MAAMd,OAA9D,IAAyEc,MAAM3B,QAAN,IAAkB2B,MAAMtB,QAArG,EAA+G;AAC3G,mBAAO,KAAKqD,WAAL,EAAP;AACH;;AAED,YAAI/B,OAAOrC,UAAP,IAAqBqC,OAAOvC,aAAhC,EAA+C;AAC3C,mBAAO,KAAKuE,UAAL,CAAgBhC,EAAhB,CAAP;AACH;;AAED,YAAIA,OAAOjC,QAAX,EAAqB;AACjB,gBAAIkE,MAAM,KAAKtC,UAAL,CAAgB,KAAKI,QAAL,GAAgB,CAAhC,CAAV;AACA,gBAAIkC,OAAOhE,SAAP,IAAoBgE,OAAO7D,SAA/B,EAA0C;AACtC,uBAAO,KAAK0D,WAAL,CAAiB/D,QAAjB,CAAP;AACH;AACJ;;AAED,eAAO,KAAKmE,UAAL,CAAgBlC,EAAhB,KAAuB,KAAKkB,KAAL,CAAY,yBAAwBiB,KAAKC,SAAL,CAAexC,OAAOyC,YAAP,CAAoBrC,EAApB,CAAf,CAAwC,EAA5E,CAA9B;AACH;;AAED6B,iBAAa;;AAET,cAAMlC,aAAa,KAAKA,UAAxB;AACA,YAAIK,EAAJ;AAAA,YAAQD,WAAW,KAAKA,QAAxB;AAAA,YAAkCkC,MAAMtC,WAAW,EAAEI,QAAb,CAAxC;;AAEA,YAAIkC,QAAQhD,OAAR,IAAmBgD,QAAQxD,QAA/B,EAAyC;AACrC,mBAAO,CAACuB,KAAKL,WAAW,EAAEI,QAAb,CAAN,MACHC,MAAM/B,SAAN,IAAmB+B,MAAM5B,SAAzB,IAAsC4B,MAAMnB,OAAN,IAAiBmB,MAAMhB,OAA7D,IAAwEgB,MAAM3B,QAAN,IAAkB2B,MAAMxB,QAD7F,CAAP,EAEG,SAAS;AACf,SAJD,MAIO,IAAIyD,QAAQnD,OAAR,IAAmBmD,QAAQ3D,QAA/B,EAAyC;AAC5C,mBAAO,CAAC0B,KAAKL,WAAW,EAAEI,QAAb,CAAN,KACHC,MAAM/B,SAAN,IAAmB+B,MAAM9B,QAD7B,EAEG,SAAS;AACf,SAJM,MAIA,IAAI+D,OAAOhE,SAAP,IAAoBgE,MAAM9D,UAA9B,EAA0C;AAC7C,mBAAO,CAAC6B,KAAKL,WAAW,EAAEI,QAAb,CAAN,KACHC,MAAM/B,SAAN,IAAmB+B,KAAK7B,UAD5B,EAEG,SAAS;AACf,SAJM,MAIA;AACH,mBAAO,KAAK2D,WAAL,EAAP;AACH;;AAED,eAAO,KAAKQ,YAAL,CAAkB,iBAAOC,MAAzB,EAAiCxC,QAAjC,CAAP;AACH;;AAED+B,gBAAY9B,EAAZ,EAAgB;AACZ,YAAID,WAAW,KAAKA,QAApB;;AAEA,YAAIC,OAAOjC,QAAX,EAAqB;AACjB,mBAAO,CAACiC,KAAK,KAAKL,UAAL,CAAgB,EAAEI,QAAlB,CAAN,KAAuCC,MAAM/B,SAAN,IAAmB+B,MAAM5B,SAAvE,EAAmF,aAAa;AACnG;;AAED,YAAI4B,OAAOjC,QAAX,EAAqB;AACjB,mBAAO,CAACiC,KAAK,KAAKL,UAAL,CAAgB,EAAEI,QAAlB,CAAN,KAAuCC,MAAM/B,SAAN,IAAmB+B,MAAM5B,SAAvE,CAAmF;AACtF;;AAED,YAAI4B,OAAOjB,OAAP,IAAkBiB,OAAOzB,QAA7B,EAAuC;AACnC,gBAAI,CAACyB,KAAK,KAAKL,UAAL,CAAgBI,WAAW,CAA3B,CAAN,MAAyClC,QAAzC,IAAqDmC,OAAOlC,SAAhE,EAA2EiC;;AAE3E,mBAAO,CAACC,KAAK,KAAKL,UAAL,CAAgB,EAAEI,QAAlB,CAAN,KAAuCC,MAAM/B,SAAN,IAAmB+B,MAAM5B,SAAvE,CAAmF;AACtF;;AAED,eAAO,KAAKkE,YAAL,CAAkB,iBAAOC,MAAzB,EAAiCxC,QAAjC,CAAP;AACH;;AAEDgC,kBAAc;AACV,cAAMtC,SAAS,KAAKA,MAApB;AACA,YAAIO,EAAJ;AAAA,YAAQD,WAAW,KAAKA,QAAxB;;AAEA,eAAO,CAACC,KAAKP,OAAOE,UAAP,CAAkB,EAAEI,QAApB,CAAN,MACHC,MAAMnB,OAAN,IAAiBmB,MAAMd,OAAvB,IAAkCc,MAAM3B,QAAN,IAAkB2B,MAAMtB,QAA1D,IACAsB,MAAM/B,SAAN,IAAmB+B,MAAM5B,SADzB,IAEA4B,OAAOpB,OAFP,IAEkBoB,OAAOtC,UAHtB,CAAP,CAIG;;AAEH,eAAO,KAAK8E,cAAL,CAAoBzC,QAApB,CAAP;AACH;;AAEDiC,eAAWS,KAAX,EAAkB;AACd,cAAM9C,aAAa,KAAKA,UAAxB;AACA,YAAIK,EAAJ;AAAA,YAAQD,WAAW,KAAKA,QAAxB;AAAA,YAAkC2C,SAAS,KAA3C;;AAEA,eAAO1C,KAAKL,WAAW,EAAEI,QAAb,CAAZ,EAAoC,IAAI2C,MAAJ,EAAY;AAC5CA,qBAAS,KAAT;AACH,SAFmC,MAE7B,IAAI1C,OAAOrB,SAAX,EAAsB;AACzB+D,qBAAS,IAAT;AACH,SAFM,MAEA,IAAI1C,OAAOyC,KAAX,EAAkB;AACrB,mBAAO,KAAKH,YAAL,CAAkB,iBAAO1C,MAAzB,EAAiCG,WAAW,CAA5C,CAAP;AACH,SAFM,MAEA,IAAIC,OAAO1C,OAAX,EAAoB;AACvB;AACH;;AAED,aAAK4D,KAAL,CAAW,2BAAX,EAAwCnB,QAAxC;AACH;;AAEDmC,eAAWlC,EAAX,EAAe;AACX,cAAM2C,OAAO,KAAK1C,OAAL,CAAaC,OAAb,CAAqBF,EAArB,EAAyB,KAAKD,QAA9B,EAAwC,KAAKJ,UAA7C,CAAb;AACA,YAAIgD,IAAJ,EAAU;AACN,gBAAIC,QAAQ,KAAKzC,KAAL,CAAW0C,GAAX,CAAeF,IAAf,CAAZ;AACA,gBAAI,CAACC,KAAL,EAAY;AACR,qBAAKzC,KAAL,CAAW2C,GAAX,CAAeH,IAAf,EAAqBC,QAAQ,EAACG,MAAM,iBAAOzC,MAAd,EAAsBqC,MAAMA,IAA5B,EAA7B;AACH;AACD,iBAAK5C,QAAL,IAAiB4C,KAAKK,MAAtB;AACA,iBAAKhD,EAAL,GAAU,IAAV;AACA,mBAAO4C,KAAP;AACH;AACJ;;AAEDJ,mBAAeS,EAAf,EAAmB;AACf,cAAMN,OAAO,KAAKlD,MAAL,CAAY4B,SAAZ,CAAsB,KAAKtB,QAA3B,EAAqCkD,EAArC,CAAb;AACA,YAAIL,QAAQ,KAAKzC,KAAL,CAAW0C,GAAX,CAAeF,IAAf,CAAZ;AACA,YAAI,CAACC,KAAL,EAAY;AACR,iBAAKzC,KAAL,CAAW2C,GAAX,CAAeH,IAAf,EAAqBC,QAAQ,EAACG,MAAM,iBAAOG,OAAd,EAAuBP,MAAMA,IAA7B,EAA7B;AACH;AACD,aAAK5C,QAAL,GAAgBkD,EAAhB;AACA,aAAKjD,EAAL,GAAU,IAAV;AACA,eAAO4C,KAAP;AACH;;AAEDN,iBAAaS,IAAb,EAAmBE,EAAnB,EAAuB;AACnB,cAAML,QAAQ,EAACG,MAAMA,IAAP,EAAaJ,MAAM,KAAKlD,MAAL,CAAY4B,SAAZ,CAAsB,KAAKtB,QAA3B,EAAqCkD,EAArC,CAAnB,EAAd;AACA,aAAKlD,QAAL,GAAgBkD,EAAhB;AACA,aAAKjD,EAAL,GAAU,IAAV;AACA,eAAO4C,KAAP;AACH;;AAEDO,YAAQnD,EAAR,EAAY;AACR,YAAIA,QAAQ,KAAKA,EAAL,IAAW,KAAK2B,OAAL,EAAnB,CAAJ,EAAwC;AACpC,iBAAK5B,QAAL;AACA,iBAAKC,EAAL,GAAU,IAAV;AACA,mBAAO,IAAP;AACH;AACJ;;AAEDoD,WAAOpD,EAAP,EAAW;AACP,YAAIA,QAAQ,KAAKA,EAAL,IAAW,KAAK2B,OAAL,EAAnB,CAAJ,EAAwC;AACpC,iBAAK5B,QAAL;AACA,iBAAKC,EAAL,GAAU,IAAV;AACH,SAHD,MAGO;AACH,iBAAKkB,KAAL,CAAY,YAAYtB,OAAOyC,YAAP,CAAoBrC,EAApB,CAAyB,YAAY,KAAKP,MAAL,CAAY4D,MAAZ,CAAmB,KAAKtD,QAAxB,CAAmC,EAAhG;AACH;AACJ;;AAEDuD,eAAWtD,EAAX,EAAe;AACX,YAAIA,QAAQ,KAAKA,EAAL,IAAW,KAAK2B,OAAL,EAAnB,KAAsC3B,OAAO,KAAKP,MAAL,CAAYE,UAAZ,CAAuB,KAAKI,QAAL,GAAgB,CAAvC,CAAjD,EAA4F;AACxF,iBAAKA,QAAL,IAAiB,CAAjB;AACA,iBAAKC,EAAL,GAAU,IAAV;AACA,mBAAO,IAAP;AACH;AACJ;;AAEDuD,iBAAavD,EAAb,EAAiB;AACb,YAAIA,QAAQ,KAAKA,EAAL,IAAW,KAAK2B,OAAL,EAAnB,KAAsC3B,OAAO,KAAKP,MAAL,CAAYE,UAAZ,CAAuB,KAAKI,QAAL,GAAgB,CAAvC,CAA7C,IAA0FC,OAAO,KAAKP,MAAL,CAAYE,UAAZ,CAAuB,KAAKI,QAAL,GAAgB,CAAvC,CAArG,EAAgJ;AAC5I,iBAAKA,QAAL,IAAiB,CAAjB;AACA,iBAAKC,EAAL,GAAU,IAAV;AACA,mBAAO,IAAP;AACH;AACJ;;AAEDwD,gBAAYb,IAAZ,EAAkB;;AAEd,YAAI,CAAC,KAAKhB,OAAL,EAAL,EAAqB,OAAO,KAAP;;AAErB,YAAI8B,IAAId,KAAKK,MAAb;;AAEA,eAAOS,GAAP,EAAY,IAAI,KAAKhE,MAAL,CAAYE,UAAZ,CAAuB,KAAKI,QAAL,GAAgB0D,CAAvC,MAA8Cd,KAAKhD,UAAL,CAAgB8D,CAAhB,CAAlD,EAAsE;AAC9E,mBAAO,KAAP;AACH;;AAED,aAAK1D,QAAL,IAAiB4C,KAAKK,MAAtB;AACA,aAAKhD,EAAL,GAAU,IAAV;AACA,eAAO2C,IAAP;AACH;;AAEDe,kBAAcC,OAAO,SAArB,EAAgC;AAC5B,YAAIhB,IAAJ;AACA,YAAIA,OAAO,KAAK1C,OAAL,CAAa0D,IAAb,EAAmB,KAAK3D,EAAL,IAAW,KAAK2B,OAAL,EAA9B,EAA8C,KAAK5B,QAAnD,EAA6D,KAAKJ,UAAlE,CAAX,EAA0F;AACtF,iBAAKI,QAAL,IAAiB4C,KAAKK,MAAtB;AACA,iBAAKhD,EAAL,GAAU,IAAV;AACA,mBAAO2C,IAAP;AACH;AACJ;;AAEDiB,eAAWjB,IAAX,EAAiB;AACb,YAAI,CAAC,KAAKa,WAAL,CAAiBb,IAAjB,CAAL,EAA6B;AACzB,iBAAKzB,KAAL,CAAY,YACRiB,KAAKC,SAAL,CAAeO,IAAf,CACC,YACDR,KAAKC,SAAL,CAAe,KAAK3C,MAAL,CAAY4B,SAAZ,CAAsB,KAAKtB,QAA3B,EAAqC8D,OAAO,CAA5C,CAAf,CACC,EAJL;AAMH;AACJ;;AAED,QAAIlD,IAAJ,GAAW;AACP,eAAO,KAAKZ,QAAL,GAAgB,KAAKN,MAAL,CAAYuD,MAAnC;AACH;;AAEDpB,YAAQ;AACJ,aAAK7B,QAAL,GAAgB,KAAKN,MAAL,CAAYuD,MAA5B;AACA,aAAKhD,EAAL,GAAU,IAAV;AACH;AA5Tc,C;;AA+TnB;;;;IAGa8D,S,WAAAA,S,GAAN,MAAMA,SAAN,SAAwBvE,KAAxB,CAA8B;;AAEjCc,SAAKZ,MAAL,EAAa;AACT,eAAOsE,MAAMF,IAAN,CAAW,MAAMxD,IAAN,CAAWZ,MAAX,CAAX,CAAP;AACH;;AAEDyC,eAAWlC,EAAX,EAAe;AACX,cAAM6D,OAAO,KAAK9D,QAAlB;AACA,YAAIiE,SAAS,MAAM9B,UAAN,CAAiBlC,EAAjB,CAAb;AACA,eAAOgE,UAAUC,OAAOC,MAAP,CAAcF,MAAd,EAAsB;AACnCjE,sBAAU,EAACoE,YAAY,KAAb,EAAoB1D,OAAOoD,IAA3B,EADyB;AAEnC/C,oBAAQ,EAACqD,YAAY,KAAb,EAAoB1D,OAAOlB,MAAMuB,MAAN,CAAahB,IAAb,CAAkB,IAAlB,EAAwB,KAAKL,MAA7B,EAAqCoE,IAArC,CAA3B;AAF2B,SAAtB,CAAjB;AAIH;;AAEDrB,mBAAeS,EAAf,EAAmB;AACf,cAAMY,OAAO,KAAK9D,QAAlB;AACA,eAAOkE,OAAOC,MAAP,CAAc,MAAM1B,cAAN,CAAqBS,EAArB,CAAd,EAAwC;AAC3ClD,sBAAU,EAACoE,YAAY,KAAb,EAAoB1D,OAAOoD,IAA3B,EADiC;AAE3C/C,oBAAQ,EAACqD,YAAY,KAAb,EAAoB1D,OAAOlB,MAAMuB,MAAN,CAAahB,IAAb,CAAkB,IAAlB,EAAwB,KAAKL,MAA7B,EAAqCoE,IAArC,CAA3B;AAFmC,SAAxC,CAAP;AAIH;;AAEDvB,iBAAaS,IAAb,EAAmBE,EAAnB,EAAuB;AACnB,cAAMY,OAAO,KAAK9D,QAAlB;AACA,eAAOkE,OAAOC,MAAP,CAAc,MAAM5B,YAAN,CAAmBS,IAAnB,EAAyBE,EAAzB,CAAd,EAA4C;AAC/ClD,sBAAU,EAACoE,YAAY,KAAb,EAAoB1D,OAAOoD,IAA3B,EADqC;AAE/C/C,oBAAQ,EAACqD,YAAY,KAAb,EAAoB1D,OAAOlB,MAAMuB,MAAN,CAAahB,IAAb,CAAkB,IAAlB,EAAwB,KAAKL,MAA7B,EAAqCoE,IAArC,CAA3B;AAFuC,SAA5C,CAAP;AAIH;AA7BgC,C;;;AAgCrCtE,MAAMD,cAAN,GAAuBA,cAAvB;;AAEA;;;;;AAKA,SAASA,cAAT,CAAwB8E,WAAxB,EAAqC;;AAEjC,UAAMnE,UAAU,EAAhB;;AAEA,QAAIC,UAAU,CAAC,CAAC,SAAD,EAAY6D,MAAMlE,SAAN,CAAgBwE,MAAhB,CAAuB,GAAGJ,OAAOK,MAAP,CAAcF,WAAd,CAA1B,CAAZ,CAAD,CAAd;;AAEA;AACA,SAAK,MAAM,CAACG,GAAD,EAAM9D,KAAN,CAAX,IAA2BwD,OAAOO,OAAP,CAAeJ,WAAf,EAA4BC,MAA5B,CAAmCnE,OAAnC,CAA3B,EAAwE;;AAEpE,cAAMuE,MAAM,IAAIrE,GAAJ,EAAZ;;AAEA,aAAK,MAAMuC,IAAX,IAAmBlC,KAAnB,EAA0B;AACtB,gBAAIiE,IAAID,GAAR;AAAA,gBAAazE,EAAb;AAAA,gBAAiB2E,IAAI,CAArB;AACA,mBAAO3E,KAAK2C,KAAKhD,UAAL,CAAgBgF,GAAhB,CAAZ,EAAkC;AAC9B,oBAAI,CAACD,EAAEE,GAAF,CAAM5E,EAAN,CAAL,EAAgB;AACZ0E,sBAAE5B,GAAF,CAAM9C,EAAN,EAAU,IAAII,GAAJ,EAAV;AACH;AACDsE,oBAAIA,EAAE7B,GAAF,CAAM7C,EAAN,CAAJ;AACH;AACD0E,cAAEV,MAAF,GAAWrB,IAAX;AACH;;AAED,cAAMkC,OAAO,CAAC,IAAD,CAAb;AACAA,aAAKhC,GAAL,GAAW,UAAUpB,KAAV,EAAiB;AACxB,mBAAO,KAAKA,KAAL,KAAe,OAAO,KAAKA,KAAL,IAAc,MAAMA,KAA3B,IAAoC,aAApC,GAAoDA,KAApD,GAA4D,IAAlF;AACH,SAFD;;AAIAxB,gBAAQsE,GAAR,IAAe,IAAIO,QAAJ,CAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EACV,GAAEC,aAAaN,GAAb,EAAkBI,IAAlB,CAAwB,uCAAsCN,GAAI,EAD1D,CAAf;AAGH;;AAED,WAAOtE,OAAP;AACH;;AAED,SAAS8E,YAAT,CAAsBN,GAAtB,EAA2BI,IAA3B,EAAiCG,MAAM,IAAvC,EAA6CvD,QAAQ,CAArD,EAAwD;;AAEpD,QAAIwD,YAAY,EAAhB;;AAEA,SAAK,IAAI,CAACjF,EAAD,EAAKkF,IAAL,CAAT,IAAuBT,GAAvB,EAA4B;AACxB,YAAI7D,OAAOa,QAAQ,CAAnB;AACA,YAAI0D,YAAYN,KAAKhC,GAAL,CAASpB,KAAT,IAAkB,OAAlB,GAA4BzB,EAA5C;AACA,eAAOkF,KAAKE,IAAL,KAAc,CAAd,IAAmB,CAACF,KAAKG,cAAL,CAAoB,QAApB,CAA3B,EAA0D;AACtD,aAACrF,EAAD,EAAKkF,IAAL,IAAaA,KAAKV,OAAL,GAAe5D,IAAf,GAAsBH,KAAnC;AACA0E,yBAAa,SAASN,KAAKhC,GAAL,CAASjC,MAAT,CAAT,GAA4B,OAA5B,GAAsCZ,EAAnD;AACH;AACD,YAAIkF,KAAKE,IAAL,GAAY,CAAZ,IAAiBF,KAAKE,IAAL,KAAc,CAAd,IAAmBF,KAAKG,cAAL,CAAoB,QAApB,CAAxC,EAAuE;AACnEJ,yBAAaD,MAAM,MAAN,GAAeG,SAAf,GAA2B,OAA3B,GAAqCJ,aAAaG,IAAb,EAAmBL,IAAnB,EAAyBG,MAAM,IAA/B,EAAqCpE,IAArC,CAArC,GAAkFoE,GAAlF,GAAwF,KAArG;AACH,SAFD,MAEO;AACHC,yBAAaD,MAAM,MAAN,GAAeG,SAAf,GAA2B,IAA3B,GAAkCJ,aAAaG,IAAb,EAAmBL,IAAnB,EAAyB,EAAzB,EAA6BjE,IAA7B,CAA/C;AACH;AACJ;;AAED,QAAI6D,IAAIY,cAAJ,CAAmB,QAAnB,CAAJ,EAAkC;AAC9BJ,qBAAaD,MAAM,SAAN,GAAkB7C,KAAKC,SAAL,CAAeqC,IAAIT,MAAnB,CAAlB,GAA+C,KAA5D;AACH;;AAED,QAAIvC,UAAU,CAAd,EAAiB;AACb,YAAIoD,KAAK7B,MAAL,GAAc,CAAlB,EAAqB;AACjB6B,iBAAKS,KAAL;AACA,mBAAON,MAAM,MAAN,GAAeH,KAAKnD,IAAL,CAAU,IAAV,CAAf,GAAiC,KAAjC,GAAyCuD,SAAhD;AACH;AACJ;;AAED,WAAOA,SAAP;AACH","file":"lexer.js","sourcesContent":["import {CharCode} from \"./charcodes.js\";\nimport {Symbols, Tokens} from \"./language.js\";\n\nconst {\n    NewLine, Tab, Space, QuotationMark, DollarSign, Apostrophe, Asterisk, PlusSign, MinusSign, FullStop, Slash,\n    DigitZero, DigitOne, DigitEight, DigitNine, CapitalA, CapitalB, CapitalE, CapitalF, CapitalX, CapitalZ,\n    Backslash, LowLine, LetterA, LetterB, LetterE, LetterF, LetterX, LetterZ, Tilde, NBSP\n} = CharCode;\n\nconst defaultSymbols = compileSymbols(Symbols);\n\n/**\n *\n */\nexport class Lexer {\n\n    constructor() {\n        this.source = typeof arguments[0] === \"string\" ? arguments[0] : '';\n        this.charCodeAt = String.prototype.charCodeAt.bind(this.source);\n        this.position = 0;\n        this.cc = null;\n        this.symbols = arguments[1] || arguments[0] || defaultSymbols;\n        if (!this.symbols.__all__) {\n            this.symbols = compileSymbols(this.symbols);\n        }\n        this.cache = new Map();\n    }\n\n    scan(source = this.source) {\n        this.source = source;\n        this.charCodeAt = String.prototype.charCodeAt.bind(source);\n        this.position = 0;\n        this.cc = null;\n        return this;\n    }\n\n    [Symbol.iterator]() {\n        const lexer = this;\n        return {\n            value: undefined,\n            done: false,\n            next() {\n                this.done = !(this.value = lexer.nextToken());\n                return this;\n            }\n        };\n    }\n\n    static cursor(source, end) {\n        let cc, position = 0, line = 1, column = 1;\n        while (position < end && (cc = source.charCodeAt(position++))) if (cc === NewLine) {\n            line++;\n            column = 1;\n        } else if (cc === Tab) {\n            column += 4;\n        } else {\n            column++;\n        }\n        return {line, column};\n    }\n\n    cursor() {\n        return Lexer.cursor(this.source, this.position);\n    }\n\n    error(message, position = this.position) {\n        const {line, column} = Lexer.cursor(this.source, position);\n        const error = new Error(`Given: \\x1b[30m\"\\x1b[32m${\n            this.source.substring(0, position) + \"\\x1b[31m\" + this.source.substring(position)\n        }\\x1b[30m\"\\x1b[0m. ${ message }, at line: \\x1b[34m${ line }\\x1b[0m, column: \\x1b[34m${ column }\\x1b[0m.`);\n        error.stack = error.stack.split(\"\\n\").filter((line, index) => index > 1).join(\"\\n\");\n        throw error;\n    }\n\n    /**\n     * Consumes all whitespaces and comments. Stops at the first character of a valid token.\n     *\n     * @returns {Number} the first non whitespace non comment charcode\n     */\n    advance() {\n\n        const charCodeAt = this.charCodeAt;\n        let cc, position = this.position;\n\n        while ((cc = charCodeAt(position)) <= Space || cc === Slash || Tilde < cc && cc < NBSP) {\n\n            if (cc === Slash) if ((cc = charCodeAt(position + 1)) === Slash) {\n\n                position++;\n\n                while ((cc = charCodeAt(++position)) && cc !== NewLine) /* ... */;\n\n                continue;\n\n            } else if (cc === Asterisk) {\n\n                position++;\n\n                while (cc = charCodeAt(++position)) if (Asterisk === cc && Slash === charCodeAt(position + 1)) {\n                    position += 2;\n                    break;\n                }\n\n                if (cc) continue; else this.error('Comment not closed', position);\n\n            } else {\n                this.position = position;\n                return this.cc = Slash;\n            }\n\n            position++;\n        }\n\n        this.position = position;\n        return this.cc = cc;\n    }\n\n    nextToken() {\n\n        let cc = this.cc || this.advance();\n        if (!cc) {\n            return this.close();\n        }\n\n        if (cc === DigitZero) {\n            return this.nextNumber();\n        }\n\n        if (cc > DigitZero && cc <= DigitNine) {\n            return this.nextDecimal();\n        }\n\n        if (cc === LowLine || cc === DollarSign || cc >= LetterA && cc <= LetterZ || cc >= CapitalA && cc <= CapitalZ) {\n            return this.nextLiteral();\n        }\n\n        if (cc === Apostrophe || cc === QuotationMark) {\n            return this.nextString(cc);\n        }\n\n        if (cc === FullStop) {\n            let cc2 = this.charCodeAt(this.position + 1);\n            if (cc2 >= DigitZero && cc2 <= DigitNine) {\n                return this.nextDecimal(FullStop);\n            }\n        }\n\n        return this.nextSymbol(cc) || this.error(`Unexpected character: ${JSON.stringify(String.fromCharCode(cc))}`);\n    }\n\n    nextNumber() {\n\n        const charCodeAt = this.charCodeAt;\n        let cc, position = this.position, cc2 = charCodeAt(++position);\n\n        if (cc2 === LetterX || cc2 === CapitalX) {\n            while ((cc = charCodeAt(++position)) && (\n                cc >= DigitZero && cc <= DigitNine || cc >= LetterA && cc <= LetterF || cc >= CapitalA && cc <= CapitalF\n            )) /* ... */;\n        } else if (cc2 === LetterB || cc2 === CapitalB) {\n            while ((cc = charCodeAt(++position)) && (\n                cc >= DigitZero && cc <= DigitOne\n            )) /* ... */;\n        } else if (cc2 >= DigitZero && cc2 < DigitEight) {\n            while ((cc = charCodeAt(++position)) && (\n                cc >= DigitZero && cc < DigitEight\n            )) /* ... */;\n        } else {\n            return this.nextDecimal();\n        }\n\n        return this.provideToken(Tokens.Number, position);\n    }\n\n    nextDecimal(cc) {\n        let position = this.position;\n\n        if (cc !== FullStop) {\n            while ((cc = this.charCodeAt(++position)) && (cc >= DigitZero && cc <= DigitNine)) /* ignored */;\n        }\n\n        if (cc === FullStop) {\n            while ((cc = this.charCodeAt(++position)) && (cc >= DigitZero && cc <= DigitNine)) ;\n        }\n\n        if (cc === LetterE || cc === CapitalE) {\n            if ((cc = this.charCodeAt(position + 1)) === PlusSign || cc === MinusSign) position++;\n\n            while ((cc = this.charCodeAt(++position)) && (cc >= DigitZero && cc <= DigitNine)) ;\n        }\n\n        return this.provideToken(Tokens.Number, position);\n    }\n\n    nextLiteral() {\n        const source = this.source;\n        let cc, position = this.position;\n\n        while ((cc = source.charCodeAt(++position)) && (\n            cc >= LetterA && cc <= LetterZ || cc >= CapitalA && cc <= CapitalZ ||\n            cc >= DigitZero && cc <= DigitNine ||\n            cc === LowLine || cc === DollarSign\n        )) ;\n\n        return this.provideLiteral(position);\n    }\n\n    nextString(quote) {\n        const charCodeAt = this.charCodeAt;\n        let cc, position = this.position, escape = false;\n\n        while (cc = charCodeAt(++position)) if (escape) {\n            escape = false;\n        } else if (cc === Backslash) {\n            escape = true;\n        } else if (cc === quote) {\n            return this.provideToken(Tokens.String, position + 1);\n        } else if (cc === NewLine) {\n            break;\n        }\n\n        this.error('String literal not closed', position);\n    }\n\n    nextSymbol(cc) {\n        const text = this.symbols.__all__(cc, this.position, this.charCodeAt);\n        if (text) {\n            let token = this.cache.get(text);\n            if (!token) {\n                this.cache.set(text, token = {type: Tokens.Symbol, text: text});\n            }\n            this.position += text.length;\n            this.cc = null;\n            return token;\n        }\n    }\n\n    provideLiteral(to) {\n        const text = this.source.substring(this.position, to);\n        let token = this.cache.get(text);\n        if (!token) {\n            this.cache.set(text, token = {type: Tokens.Literal, text: text});\n        }\n        this.position = to;\n        this.cc = null;\n        return token;\n    }\n\n    provideToken(type, to) {\n        const token = {type: type, text: this.source.substring(this.position, to)};\n        this.position = to;\n        this.cc = null;\n        return token;\n    }\n\n    consume(cc) {\n        if (cc === (this.cc || this.advance())) {\n            this.position++;\n            this.cc = null;\n            return true;\n        }\n    }\n\n    expect(cc) {\n        if (cc === (this.cc || this.advance())) {\n            this.position++;\n            this.cc = null;\n        } else {\n            this.error(`Expected ${ String.fromCharCode(cc) } but was ${ this.source.charAt(this.position) }`);\n        }\n    }\n\n    consumeTwo(cc) {\n        if (cc === (this.cc || this.advance()) && cc === this.source.charCodeAt(this.position + 1)) {\n            this.position += 2;\n            this.cc = null;\n            return true;\n        }\n    }\n\n    consumeThree(cc) {\n        if (cc === (this.cc || this.advance()) && cc === this.source.charCodeAt(this.position + 1) && cc === this.source.charCodeAt(this.position + 2)) {\n            this.position += 3;\n            this.cc = null;\n            return true;\n        }\n    }\n\n    consumeText(text) {\n\n        if (!this.advance()) return false;\n\n        let p = text.length;\n\n        while (p--) if (this.source.charCodeAt(this.position + p) !== text.charCodeAt(p)) {\n            return false\n        }\n\n        this.position += text.length;\n        this.cc = null;\n        return text;\n    }\n\n    consumeSymbol(name = '__all__') {\n        let text;\n        if (text = this.symbols[name](this.cc || this.advance(), this.position, this.charCodeAt)) {\n            this.position += text.length;\n            this.cc = null;\n            return text;\n        }\n    }\n\n    expectText(text) {\n        if (!this.consumeText(text)) {\n            this.error(`Expected ${\n                JSON.stringify(text)\n                } but was ${\n                JSON.stringify(this.source.substring(this.position, from + 1))\n                }`\n            );\n        }\n    }\n\n    get done() {\n        return this.position < this.source.length;\n    }\n\n    close() {\n        this.position = this.source.length;\n        this.cc = null;\n    }\n}\n\n/**\n *\n */\nexport class Tokenizer extends Lexer {\n\n    scan(source) {\n        return Array.from(super.scan(source));\n    }\n\n    nextSymbol(cc) {\n        const from = this.position;\n        let symbol = super.nextSymbol(cc);\n        return symbol && Object.create(symbol, {\n            position: {enumerable: false, value: from},\n            cursor: {enumerable: false, value: Lexer.cursor.bind(null, this.source, from)}\n        });\n    }\n\n    provideLiteral(to) {\n        const from = this.position;\n        return Object.create(super.provideLiteral(to), {\n            position: {enumerable: false, value: from},\n            cursor: {enumerable: false, value: Lexer.cursor.bind(null, this.source, from)}\n        });\n    }\n\n    provideToken(type, to) {\n        const from = this.position;\n        return Object.create(super.provideToken(type, to), {\n            position: {enumerable: false, value: from},\n            cursor: {enumerable: false, value: Lexer.cursor.bind(null, this.source, from)}\n        });\n    }\n}\n\nLexer.compileSymbols = compileSymbols;\n\n/**\n *\n * @param definitions\n * @return {*}\n */\nfunction compileSymbols(definitions) {\n\n    const symbols = {};\n\n    let __all__ = [['__all__', Array.prototype.concat(...Object.values(definitions))]];\n\n    /* istanbul ignore next */\n    for (const [key, value] of Object.entries(definitions).concat(__all__)) {\n\n        const ast = new Map();\n\n        for (const text of value) {\n            let t = ast, cc, c = 0;\n            while (cc = text.charCodeAt(c++)) {\n                if (!t.has(cc)) {\n                    t.set(cc, new Map());\n                }\n                t = t.get(cc);\n            }\n            t.symbol = text;\n        }\n\n        const vars = [\"c0\"];\n        vars.get = function (index) {\n            return this[index] || \"(\" + (this[index] = \"c\" + index) + \" = cc(cp + \" + index + \"))\";\n        };\n\n        symbols[key] = new Function(\"c0\", \"cp\", \"cc\",\n            `${generateBody(ast, vars)}//# sourceURL=http://majorana/lexer/${key}`\n        );\n    }\n\n    return symbols;\n}\n\nfunction generateBody(ast, vars, tab = '\\t', index = 0) {\n\n    let statement = '';\n\n    for (let [cc, node] of ast) {\n        let next = index + 1;\n        let condition = vars.get(index) + \" === \" + cc;\n        while (node.size === 1 && !node.hasOwnProperty('symbol')) {\n            [cc, node] = node.entries().next().value;\n            condition += \" && \" + vars.get(next++) + \" === \" + cc;\n        }\n        if (node.size > 1 || node.size === 1 && node.hasOwnProperty('symbol')) {\n            statement += tab + \"if (\" + condition + \") {\\n\" + generateBody(node, vars, tab + '  ', next) + tab + \"}\\n\";\n        } else {\n            statement += tab + \"if (\" + condition + \") \" + generateBody(node, vars, '', next);\n        }\n    }\n\n    if (ast.hasOwnProperty('symbol')) {\n        statement += tab + \"return \" + JSON.stringify(ast.symbol) + \";\\n\";\n    }\n\n    if (index === 0) {\n        if (vars.length > 1) {\n            vars.shift();\n            return tab + \"let \" + vars.join(\", \") + \";\\n\" + statement;\n        }\n    }\n\n    return statement;\n}"]}